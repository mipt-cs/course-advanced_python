Обработка аргументов командной строки. Библиотеки sys и argparse. Декораторы
############################################################################

:date: 2019-09-19 19:00
:summary: Обработка аргументов командной строки. Библиотека sys и argparse. Декораторы
:status: published

.. default-role:: code

.. role:: python(code)
   :language: python

.. contents::

Обработка аргументов командной строки. Запуск   программы   с   аргументами
===========================================================================

Параметры запуска, задаваемые через командную строку, чаще всего используют консольные программы, хотя программы с графическим интерфейсом тоже не брезгуют этой возможностью. Наверняка в жизни каждого программиста была ситуация, когда приходилось разбирать параметры командной строки, как правило, это не самая интересная часть программы, но без нее не обойтись. Эта статья посвящена тому, как Python облегчает жизнь программистам при решении этой задачи благодаря своей стандартной библиотеке argparse. 

Примеры без использования argparse
----------------------------------

Путь для начала у нас есть простейший скрипт на Python. Для определенности назовем скрипт coolprogram.py, это будет классический Hello World, над которым мы будем работать 

.. code:: python

   if __name__ == "__main__":
      print ("Привет, мир!")
      
Мы завершили эту сложнейшую программу и отдали ее заказчику, он доволен, но просит добавить в нее возможность указывать имя того, кого приветствуем, причем этот параметр может быть не обязательным. Т.е. программа может использоваться двумя путями:

.. code:: bash

      $ python coolprogram.py
или

.. code:: bash

      $ python coolprogram.py Вася
   
Мы можем воспользоваться переменной argv из модуля sys. sys.argv содержит список параметров, переданных программе через командную строку, причем нулевой элемент списка - это имя нашего скрипта. Т.е. если у нас есть следующий скрипт с именем params.py:

.. code:: python

   import sys

   if __name__ == "__main__":
       for param in sys.argv:
           print (param)
        
и мы запускаем его с помощью команды

.. code:: python

   python params.py

то в консоль будет выведена единственная строка:

.. code:: python

   params.py

Если же мы добавим несколько параметров,

.. code:: bash

   python params.py param1 param2 param3

то эти параметры мы увидим в списке sys.argv, начиная с первого элемента:

.. code:: python

   params.py
   param1
   param2
   param3

Здесь можно обратить внимание на то, что ссылка на интерпретатор Python в список этих параметров не входит, хотя он также присутствует в строке вызова нашего скрипта.

Вернемся к нашей задаче. Погрузившись в код на неделю, мы могли бы выдать заказчику следующий скрипт:

.. code:: python

   import sys

   if __name__ == "__main__":
       if len (sys.argv) > 1:
           print ("Привет, {}!".format (sys.argv[1] ) )
       else:
           print ("Привет, мир!")

Теперь, если программа вызывается с помощью команды

.. code:: python

   python coolprogram.py
   
то результат будет прежний

.. code:: python

   Привет, мир!
   
а если мы добавим параметр:

.. code:: python

   python coolprogram.py Вася
   
то программа поприветствует некоего Васю:

.. code:: python

   Привет, Вася!
   
Пока все легко и никаких проблем не возникает. Теперь предположим, что требования заказчика вновь изменились, и на этот раз он хочет, чтобы имя приветствуемого человека передавалось после именованного параметра --name или -n, причем нужно следить, что в командной строке передано только одно имя. С этого момента у нас начнется вермишель из конструкций if.

.. code:: python

   import sys

   if __name__ == "__main__":
       if len (sys.argv) == 1:
           print ("Привет, мир!")
       else:
           if len (sys.argv) < 3:
               print ("Ошибка. Слишком мало параметров.")
               sys.exit (1)

           if len (sys.argv) > 3:
               print ("Ошибка. Слишком много параметров.")
               sys.exit (1)

           param_name = sys.argv[1]
           param_value = sys.argv[2]

           if (param_name == "--name" or
                   param_name == "-n"):
               print ("Привет, {}!".format (param_value) )
           else:
               print ("Ошибка. Неизвестный параметр '{}'".format (param_name) )
               sys.exit (1)

Здесь мы проверяем ситуацию, что мы вообще не передали ни одного параметра, потом проверяем, что дополнительных параметров у нас ровно два, что они называются именно --name или -n, и, если нас все устраивает, выводим приветствие.

Как видите, код превратился в тихий ужас. Изменить логику работы в нем в дальнейшем будет очень сложно, а при увеличении количества параметров нужно будет срочно применять объектно-ориентированные меры по отделению логики работы программы от разбора командной строки. Разбор командной строки мы могли бы выделить в отдельный класс (или классы), но мы этого здесь делать не будем, поскольку все уже сделано в стандартной библиотеке Python, которая называется argparse.

Но перед тем, как перейти к библиотеке argparse, еще немного остановимся на sys.
Модуль sys обеспечивает доступ к некоторым переменным и функциям, взаимодействующим с интерпретатором python.
Самыми полезными являются:

   * sys.argv - список аргументов командной строки, передаваемых сценарию Python. sys.argv[0] является именем скрипта (пустой строкой в интерактивной оболочке).
   * sys.exit([arg]) - выход из Python. Функция exit принимает необязательный аргумент, обычно целое число, которое дает статус выхода. Ноль считается как успешное завершение. Обязательно проверьте, имеет ли ваша операционная система какие-либо особые значения для своих статусов выхода, чтобы вы могли следить за ними в своем собственном приложении. Обратите внимание на то, что когда вы вызываете exit, это вызовет исключение SystemExit, которое позволяет функциям очистки работать в конечных пунктах блоков try / except. 
   * sys.stdin - стандартный поток ввода.
   * sys.stdout - стандартный поток вывода.
   * sys.stderr - стандартный поток ошибок. 
     Stdin, stdout и stderr сопоставляются с файловыми объектами, которые соответствуют стандартным входам, выходам и потокам ошибок интерпретатора соответственно. Функция stdin используется для всех входов, используемых интерпретатором (за исключением скриптов), тогда как stdout используется для выходов операторов print. Эти потоки вывода можно переопределить, например для перенаправления логов вывода в графический интерфейс или в файл.
   * sys.__stdin__, sys.__stdout__, sys.__stderr__ - исходные значения потоков ввода, вывода и ошибок.

Использование библиотеки argparse
---------------------------------

Простейший случай
~~~~~~~~~~~~~~~~~

Как как было сказано выше, стандартная библиотека argparse предназначена для облегчения разбора командной строки. На нее можно возложить проверку переданных параметров: их количество и обозначения, а уже после того, как эта проверка будет выполнена автоматически, использовать полученные параметры в логике своей программы.

Основа работы с командной строкой в библиотеке argparse является класс ArgumentParser. У его конструктора и методов довольно много параметров, все их рассматривать не будем, поэтому в дальнейшем рассмотрим работу этого класса на примерах, попутно обсуждая различные параметры.

Простейший принцип работы с argparse следующий:

   1. Создаем экземпляр класса ArgumentParser.
   2. Добавляем в него информацию об ожидаемых параметрах с помощью метода add_argument (по одному вызову на каждый параметр).
   3. Разбираем командную строку помощью метода parse_args, передавая ему полученные параметры командной строки (кроме нулевого элемента списка sys.argv).
   4. Начинаем использовать полученные параметры.
   
Для начала перепишем программу coolprogram.py с единственным параметром так, чтобы она использовала библиотеку argparse. Напомню, что данном случае мы ожидаем следующий синтаксис параметров:

.. code:: python

   python coolprogram.py [Имя]

Здесь [Имя] является необязательным параметром.

Наша программа с использованием argparse может выглядеть следующим образом:

.. code:: python

   import sys
   import argparse

   def createParser ():
       parser = argparse.ArgumentParser()
       parser.add_argument ('name', nargs='?')

       return parser


   if __name__ == '__main__':
       parser = createParser()
       namespace = parser.parse_args()

       print (namespace)

       if namespace.name:
           print ("Привет, {}!".format (namespace.name) )
       else:
           print ("Привет, мир!")


На первый взгляд эта программа работает точно так же, как и раньше, хотя есть отличия, но мы их рассмотрим чуть позже. Пока разберемся с тем, что мы понаписали в программе.

Создание парсера вынесено в отдельную функцию, поскольку эта часть программы в будущем будет сильно изменяться и разрастаться. Сначала мы создали экземпляр класса ArgumentParser с параметрами по умолчанию. Что это за параметры, опять же, поговорим чуть позже.

Далее мы добавили ожидаемый параметр в командной строке с помощью метода add_argument. При этом такой параметр будет считаться позиционным, т.е. он должен стоять именно на этом месте и у него не будет никаких предварительных обозначений (мы их добавим позже в виде '-n' или '--name'). Если бы мы не добавили именованный параметр nargs='?', то этот параметр был бы обязательным. nargs может принимать различные значения. Если бы мы ему присвоили целочисленное значение больше 0, то это бы означало, что мы ожидаем ровно такое же количество передаваемых параметров (точнее, считалось бы, что первый параметр ожидал бы список из N элементов, разделенных пробелами, этот случай мы рассмотрим позже). Также этот параметр может принимать значение '?', '+', '*' и argparse.REMAINDER. Мы их не будем рассматривать, поскольку они важны в сочетании с необязательными именованными параметрами, которые могут располагаться как до, так и после нашего позиционного параметра. Тогда этот параметр будет показывать как интерпретировать список параметров, где будет заканчиваться один список параметров и начинаться другой.

Итак, мы создали парсер, после чего можно вызвать его метод parse_args для разбора командной строки. Если мы не укажем никакого параметра, это будет означать равносильно тому, что мы передадим в него все параметры из sys.argv кроме нулевого, который содержит имя нашей программы. т.е.

.. code:: python

   parser.parse_args (sys.argv[1:])

В качестве результата мы получим экземпляр класса Namespace, который будет содержать в качестве члена имя нашего параметра. Теперь  посмотрим, чему же равны наши параметры.

Если мы это сделаем и запустим программу с переданным параметром

.. code:: python

   python coolprogram.py Вася
   
, то увидим его в пространстве имен.

.. code:: python

   Namespace(name='Вася')

Если же теперь мы запустим программу без дополнительных параметров, то это значение будет равно None:

.. code:: python

   Namespace(name=None)
   
Мы можем изменить значение по умолчанию, что позволит нам несколько сократить программу. Пусть по умолчанию используется слово 'мир', ведь мы его приветствуем, если параметры не переданы. Для этого воспользуемся дополнительным именованным параметром default в методе add_argument.

.. code:: python

   import sys
   import argparse


   def createParser ():
       parser = argparse.ArgumentParser()
       parser.add_argument ('name', nargs='?', default='мир')

       return parser


   if __name__ == '__main__':
       parser = createParser()
       namespace = parser.parse_args (sys.argv[1:])

       # print (namespace)

       print ("Привет, {}!".format (namespace.name) )

Программа продолжает работать точно также, как и раньше. Вы, наверное, заметили, что в предыдущем примере в метод parse_args ередаются параметры командной строки из sys.argv. Это сделано для того, чтобы показать, что список параметров мы можем передавать явно, при необходимости мы его можем предварительно обработать, хотя это вряд ли понадобится, ведь почти всю обработку можно возложить на плечи библиотеки argparse.

Добавляем именованные параметры
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Теперь снова переделаем нашу программу таким образом, чтобы использовать именованные параметры. Напомню, что согласно последнему желанию (в смысле, для данной программы) заказчика имя приветствуемого человека должно передаваться после параметра --name или -n. С помощью pyparse сделать это проще простого - достаточно в качестве первых двух параметров метода add_argument передать эти имена параметров.

.. code:: python

   import sys
   import argparse


   def createParser ():
       parser = argparse.ArgumentParser()
       parser.add_argument ('-n', '--name', default='мир')

       return parser


   if __name__ == '__main__':
       parser = createParser()
       namespace = parser.parse_args(sys.argv[1:])

       # print (namespace)

       print ("Привет, {}!".format (namespace.name) )

Теперь, если мы запустим программу без параметров, то увидим знакомое "Привет, мир!", а если мы запустим программу с помощью команды

.. code:: python
 
   python coolprogram.py -n Вася

или

.. code:: python
 
   python coolprogram.py --name Вася

То приветствовать программа будет Васю. Обратите внимание, что теперь в методе add_argument мы убрали параметр nargs='?' , поскольку все именованные параметры считаются необязательными. А если они не обязательные, то возникает вопрос, как поведет себя argparse, если этот параметр не передан? Для этого уберем параметр default в add_argument.


.. code:: python

   import sys
   import argparse

   def createParser ():
       parser = argparse.ArgumentParser()
       parser.add_argument ('-n', '--name')

       return parser


   if __name__ == '__main__':
       parser = createParser()
       namespace = parser.parse_args(sys.argv[1:])

       print ("Привет, {}!".format (namespace.name) )

Если теперь запустить программу без параметров, то увидим приветствие великого None:

.. code:: python
 
   Привет, None!

Таким образом, если значение по умолчанию не указано, то оно считается равным None.

До этого мы задавали два имени для одного и того же параметра: длинное имя, начинающееся с "--" (--name) и короткое сокращение, начинающее ся с "-" (-n). При этом получение значение параметра из пространства имен осуществляется по длинному имени:

.. code:: python

   print ("Привет, {}!".format (namespace.name) )

Если мы не зададим длинное имя, то придется обращаться к параметру через его короткое имя (n):

.. code:: python

   import sys
   import argparse

   def createParser ():
       parser = argparse.ArgumentParser()
       parser.add_argument ('-n')

       return parser


   if __name__ == '__main__':
       parser = createParser()
       namespace = parser.parse_args(sys.argv[1:])

       print (namespace)

       print ("Привет, {}!".format (namespace.n) )

При этом пространство имен будет выглядеть как:

.. code:: python
 
   Namespace(n='Вася')

Хорошо, с уменьшением количества имен параметров разобрались, но мы можем еще и увеличить количество имен, например, мы можем добавить для того же параметра еще новое имя --username, для этого достаточно его добавить следующим параметром метода add_argument:

.. code:: python

   import sys
   import argparse

   def createParser ():
       parser = argparse.ArgumentParser()
       parser.add_argument ('-n', '--name', '--username')

       return parser


   if __name__ == '__main__':
       parser = createParser()
       namespace = parser.parse_args(sys.argv[1:])

       print (namespace)

       print ("Привет, {}!".format (namespace.name) )

Теперь мы можем использовать три варианта передачи параметров:

python coolprogram.py -n Вася
python coolprogram.py --name Вася
python coolprogram.py --username Вася

Все три варианта равнозначны, при этом надо обратить внимание, что при получении значения этого параметра используется первое длинное имя, т.е. name. Пространство имен при использовании всех трех вариантов вызова программы будет выглядеть одинаково:

.. code:: python
 
   Namespace(name='Вася')

Для полного погружения во все сложные случаи разбора параметров, можете ознакомиться со статьей https://jenyay.net/Programming/Argparse

Упражнение 1
------------
Напишите консольную программу, которой на вход подается единственное число N (без имени или с именем -n), а программа печатает значение Nго числа Фибоначчи

Декораторы
==========

Декораторы в Python и примеры их практического использования.

Итак, что же это такое? Для того, чтобы понять, как работают декораторы, в первую очередь следует вспомнить, что функции в python являются объектами, соответственно, их можно возвращать из другой функции или передавать в качестве аргумента. Также следует помнить, что функция в python может быть определена и внутри другой функции.

Вспомнив это, можно смело переходить к декораторам. Декораторы — это, по сути, "обёртки", которые дают нам возможность изменить поведение функции, не изменяя её код.

Создадим свой декоратор "вручную":

.. code:: python

    def my_shiny_new_decorator(function_to_decorate):
        # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
        # получая возможность исполнять произвольный код до и после неё.
        def the_wrapper_around_the_original_function():
            print("Я - код, который отработает до вызова функции")
            function_to_decorate() # Сама функция
            print("А я - код, срабатывающий после")
        # Вернём эту функцию
        return the_wrapper_around_the_original_function

    # Представим теперь, что у нас есть функция, которую мы не планируем больше трогать.
    def stand_alone_function():
        print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

    stand_alone_function()
    # Однако, чтобы изменить её поведение, мы можем декорировать её, то есть просто передать декоратору,
    # который обернет исходную функцию в любой код, который нам потребуется, и вернёт новую,
    # готовую к использованию функцию:
    stand_alone_function_decorated = my_shiny_new_decorator(stand_alone_function)
    stand_alone_function_decorated()

Возможно мы бы хотели, чтобы каждый раз, во время вызова stand_alone_function, вместо неё вызывалась stand_alone_function_decorated. Для этого просто перезапишем stand_alone_function:

.. code:: python

    stand_alone_function = my_shiny_new_decorator(stand_alone_function)
    stand_alone_function()

Собственно, это и есть декораторы. Вот так можно было записать предыдущий пример, используя синтаксис декораторов:

.. code:: python

    @my_shiny_new_decorator
    def another_stand_alone_function():
        print("Оставь меня в покое")

    another_stand_alone_function()

То есть, декораторы в python — это просто синтаксическая обертка для конструкций вида:

.. code:: python

    another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)

Можно использовать несколько декораций для функций:

.. code:: python

    def bread(func):
        def wrapper():
            print()
            func()
            print("<\______/>")
        return wrapper

    def ingredients(func):
        def wrapper():
            print("#помидоры#")
            func()
            print("~салат~")
        return wrapper

    def sandwich(food="--ветчина--"):
        print(food)

    sandwich()
    sandwich = bread(ingredients(sandwich))
    sandwich()

И аналогично через декораторы:

.. code:: python

    @bread
    @ingredients
    def sandwich(food="--ветчина--"):
        print(food)

    sandwich()


Не забываем, что так как порядок вызова функций имеет значение, то и порядок проставление декораторов так же имеет значение. 


Упражнение 2
------------

Напишите функцию, которая получает на вход список чисел и выдает ответ сколько в данном списке четных чисел. Напишите декоратор, который меняет поведение функции следующим образом: если четных чисел нет, то пишет "Нету(" а если их больше 10, то пишет "Очень много"

Передача декоратором аргументов в функцию
-----------------------------------------

Однако, все декораторы, которые мы рассматривали, не имели одного очень важного функционала — передачи аргументов декорируемой функции. Собственно, это тоже несложно сделать.

Текстовый данные в языке пайтон описываются классом ``str``:

.. code:: python

    def a_decorator_passing_arguments(function_to_decorate):
        def a_wrapper_accepting_arguments(arg1, arg2):
            print("Смотри, что я получил:", arg1, arg2)
            function_to_decorate(arg1, arg2)
        return a_wrapper_accepting_arguments

    # Теперь, когда мы вызываем функцию, которую возвращает декоратор, мы вызываем её "обёртку",
    # передаём ей аргументы и уже в свою очередь она передаёт их декорируемой функции
    @a_decorator_passing_arguments
    def print_full_name(first_name, last_name):
        print("Меня зовут", first_name, last_name)

    print_full_name("Vasya", "Pupkin")


Декорирование методов
---------------------

Один из важных фактов, которые следует понимать, заключается в том, что функции и методы в Python — это практически одно и то же, за исключением того, что методы всегда ожидают первым параметром ссылку на сам объект (self). Это значит, что мы можем создавать декораторы для методов точно так же, как и для функций, просто не забывая про self.

При этом строка представляет из себя объект-коллекцию и есть возможность
получить доступ к отдельным ее элементам по индексу:

.. code:: python

    def method_friendly_decorator(method_to_decorate):
        def wrapper(self, lie):
            lie -= 3
            return method_to_decorate(self, lie)
        return wrapper

    class Lucy:
        def __init__(self):
            self.age = 32
        @method_friendly_decorator
        def sayYourAge(self, lie):
            print("Мне {} лет, а ты бы сколько дал?".format(self.age + lie))

    l = Lucy()
    l.sayYourAge(-3)



Упражнение 3
------------
Воспользуйтесь написанным классом Vector2D и методом __add__. Добавьте к нему декоратор, который при вызове метода печатает сообщение вида: (1, 2) + (3, -1) = (2, 1)

А теперь попробуем написать декоратор, принимающий аргументы:

.. code:: python

    def decorator_maker():
        print("Я создаю декораторы! Я буду вызван только раз: когда ты попросишь меня создать декоратор.")
        def my_decorator(func):
            print("Я - декоратор! Я буду вызван только раз: в момент декорирования функции.")
            def wrapped():
                print ("Я - обёртка вокруг декорируемой функции.\n"
                       "Я буду вызвана каждый раз, когда ты вызываешь декорируемую функцию.\n"
                       "Я возвращаю результат работы декорируемой функции.")
                return func()
            print("Я возвращаю обёрнутую функцию.")
            return wrapped
        print("Я возвращаю декоратор.")
        return my_decorator

    # Давайте теперь создадим декоратор. Это всего лишь ещё один вызов функции
    new_decorator = decorator_maker()
    # Теперь декорируем функцию
    def decorated_function():
        print("Я - декорируемая функция.")

    decorated_function = new_decorator(decorated_function)
    # Теперь наконец вызовем функцию:
    decorated_function()

Теперь перепишем данный код с помощью декораторов:

.. code:: python

    @decorator_maker()
    def decorated_function():
        print("Я - декорируемая функция.")

    decorated_function()

Вернёмся к аргументам декораторов, ведь, если мы используем функцию, чтобы создавать декораторы "на лету", мы можем передавать ей любые аргументы, верно?


.. code:: python

    def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):
        print("Я создаю декораторы! И я получил следующие аргументы:",
               decorator_arg1, decorator_arg2)
        def my_decorator(func):
            print("Я - декоратор. И ты всё же смог передать мне эти аргументы:",
                   decorator_arg1, decorator_arg2)
            # Не перепутайте аргументы декораторов с аргументами функций!
            def wrapped(function_arg1, function_arg2):
                print ("Я - обёртка вокруг декорируемой функции.\n"
                       "И я имею доступ ко всем аргументам\n"
                       "\t- и декоратора: {0} {1}\n"
                       "\t- и функции: {2} {3}\n"
                       "Теперь я могу передать нужные аргументы дальше"
                       .format(decorator_arg1, decorator_arg2,
                               function_arg1, function_arg2))
                return func(function_arg1, function_arg2)
            return wrapped
        return my_decorator

    @decorator_maker_with_arguments("Леонард", "Шелдон")
    def decorated_function_with_arguments(function_arg1, function_arg2):
        print ("Я - декорируемая функция и я знаю только о своих аргументах: {0}"
               " {1}".format(function_arg1, function_arg2))

    decorated_function_with_arguments("Раджеш", "Говард")

Таким образом, мы можем передавать декоратору любые аргументы, как обычной функции. 

Некоторые особенности работы с декораторами
    1. Декораторы несколько замедляют вызов функции, не забывайте об этом.
    2. Вы не можете "раздекорировать" функцию. Безусловно, существуют трюки, позволяющие создать декоратор, который можно отсоединить от функции, но это плохая практика. Правильнее будет запомнить, что если функция декорирована — это не отменить.
    3. Декораторы оборачивают функции, что может затруднить отладку.



Упражнение 4
------------
Напишите декоратор, который принимает в качестве аргумента путь к файлу. Если данный декоратор добавить к функции, то в указанный файл будет логироваться информация вида:
1. Время вызова функции
2. Входящие аргументы
3. Ответ return (если есть, если нет то логгировать '-')
4. Время завершения работы функции
5. Время работы функции


Декораторы @classmethod и @staticmethod
---------------------------------------
Существуют 2 особенных декоратора, которые можно повесить на функции внутри класса. 
@staticmethod определяет обычную функцию в пространстве имён класса. Может быть полезно для вспомогательных _* функций, чтобы не мусорить пространство имён модуля.

@classmethod создаёт метод класса. Объект класса явно передаётся через первый параметр как это с параметром self происходит для обычных методов. Также как и для self, переданный cls может отличаться от класса, в котором определён класс-метод (может быть потомок). Часто используется для создания альтернативных конструкторов.

Если мы взглянем на пример кода, в котором показано, как работает декоратор, это может помочь понять основные принципы:


.. code-block:: python

    class Person: 
        def __init__(self, name, age): 
            self.name = name 
            self.age = age 
          
        # classmethod чтобы создать объект по году рождения, 
        # "альтернативный" конструктор
        @classmethod
        def fromBirthYear(cls, name, year): 
            return cls(name, date.today().year - year) 
          
        # статический метод,чтобы проверить совершеннолетие
        @staticmethod
        def isAdult(age): 
            return age > 18
      
    person1 = Person('Петя', 21) 
    person2 = Person.fromBirthYear('Петя', 1996) 
      
    print person1.age 
    print person2.age 
      
    # print the result 
    print Person.isAdult(22) 


.. parsed-literal::

    21
    21
    True

Важно понимать, что ни classmethod ни staticmethod НЕ являются функциями от конкретного объекта класса и соответственно не принимают self. Подчеркнем еще раз их различия:
    1. classmethod принимает cls как первый параметр, тогда как staticmethod в специальных аргументах не нуждается
    2. classmethod может получать доступ или менять состояние класса, в то время как staticmethod нет
    3. staticmethod в целом вообще ничего не знают про класс. Это просто функция над аргументами, объявленная внутри класса.


Упражнение 5
------------
Добавьте в класс Vector2D classmethod .copy(vector), который принимает объект класса Vector2D и создает на основе него новый вектор с такими же параметрами. Добавьте классовый метод .fromlist(list), который принимает список из двух элементов, которые соответствуют x и y.

Упражнение 6
------------
Создайте внутренний атрибут класса, обозначающий норму самого большого вектора. Создайте classmethod Vector2d.get_biggest_size() возвращающий норму самого длинного вектора.


