Повторение работы в командной строке Linux
##########################################

:date: 2018-09-08 09:00
:summary: Работа в командной строке Linux.
:status: published


.. default-role:: code

Введение
========

Kомандный интерпретатор (или командная оболочка) – это программа, принимающая и выполняющая программы. Командный интерпретатор также поддерживает конструкции программирования, позволяя составлять сложные команды из более простых. Эти сложные команды, или сценарии можно сохранять в виде файлов, которые могут становиться новыми самостоятельными командами. В действительности многие команды в обычной Linux-системе являются сценариями.
Мы рассмотрим командный интерпретатор bash – это один из нескольких интерпретаторов, доступных в Linux.

Для ввода данных и вывода результатов интерпретаторы используют три стандартных потока ввода/вывода:

#. `stdin` – стандартный поток ввода (standard input stream), обеспечивающий ввод для команд.
#. `stdout` – стандартный поток вывода (standard output stream), обеспечивающий отображение результатов выполнения команд.
#. `stderr` – стандартный поток ошибок (standard error stream), обеспечивающий отображение ошибок, возникающих при выполнении команд.


При помощи потоков ввода обеспечивается ввод данных для команд (обычно с клавиатуры). Потоки вывода отображают текстовые символы, которые обычно выводятся на экран.

Команды в ОС Linux состоят из имени, опций и параметров. Некоторые команды не имеют ни опций, ни параметров, некоторые имеют и то, и другое, а некоторые – только опции или только параметры. 


Команды
=======

echo
----

Команда echo выводит на экран свои аргументы, как показано в примере ниже

.. code-block:: bash

	[user@comp ~]$ echo Hello World
	Hello World
	[user@comp ~]$ echo Hello      World
	Hello World
	[user@comp ~]$ echo "Hello      World"
	Hello      World
	[user@comp ~]$ echo "Hello      World"  # comment here
	Hello      World
	[user@comp ~]$ echo "\"Hello  World\""  # comment here
	"Hello  World"
	[user@comp ~]$ 

Bash использует символы-разделители, такие как пробелы, символы табуляции и символы новой строки для разделения входной строки на маркеры, которые передаются на вход вашей команде, поэтому в третьей строке все пробелы были сокращены до одного. Чтобы избежать этого, необходимо заключить строку в кавычки – либо в двойные, либо в одинарные.

Другими словами, если строка заключена в кавычки, то все дополнительные символы-разделители сохраняются, и вся строка воспринимается как один маркер. Чтобы использовать кавычки внутри кавычек необходимо использовать символ \\» как показано в последнем примере.

Если строка содержит символ #, то все последующие символы вы этой строке игнорируются.


man
---

По ходу использования операционной системы Linux вам часто будет требоваться информация о том, что делает та или иная команда или системный вызов, какие у них параметры и опции, для чего предназначены некоторые системные файлы, каков их формат и т.д. Получить эту информацию можно при помощи утилиты `man`:

.. code-block:: bash

	man <имя>

где имя – это имя интересующей вас команды, утилиты, системного вызова, библиотечной функции или файла.

Например:

.. code-block:: bash

	man echo

чтобы выйти из man, нажмите клавишу «q».

Иногда имена команд интерпретатора и системных вызовов или какие-либо еще имена совпадают. Тогда чтобы найти интересующую вас информацию, необходимо задать утилите `man` категорию, к которой относится эта информация (номер раздела). Деление информации по категориям может слегка отличаться от одной версии UNIX к другой. В Linux, например, принято следующее разделение:

#. Исполняемые файлы или команды интерпретатора.
#. Системные вызовы.
#. Библиотечные функции.
#. Специальные файлы (обычно файлы устройств).
#. Формат системных файлов и принятые соглашения.
#. Игры (обычно отсутствуют).
#. Макропакеты и утилиты – такие как сам man.
#. Команды системного администратора.
#. Подпрограммы ядра (нестандартный раздел).


Если вы знаете раздел, к которому относится информация, то утилиту man можно вызвать в Linux с дополнительным параметром

.. code-block:: bash

	man <номер_раздела> <имя>

В других операционных системах этот вызов может выглядеть иначе. Для получения точной информации о разбиении на разделы, форме указания номера раздела и дополнительных возможностях утилиты man наберите команду

.. code-block:: bash

	man man


Директории. Команды pwd, ls, cd
-------------------------------

Каждая выполняемая программа «работает» в строго определённой директории файловой системы. Такая директория называется текущей директорией, можно представлять, что программа во время работы «находится» именно в этой директории, это её «рабочее место». В зависимости от текущей директория может меняться поведение программы: зачастую программа будет по умолчанию работать с файлами, расположенными именно в текущей директория — до них она «дотянется» в первую очередь. Текущая директория есть у любой программы, в том числе и у командной оболочки пользователя. Поскольку взаимодействие пользователя с системой обязательно опосредовано командной оболочкой, можно говорить о том, что пользователь «находится» в той директория, которая в данный момент является текущей директорией его командной оболочки.

Все команды, отдаваемые пользователем при помощи `bash`, наследуют текущую директорию `bash`, т. е. «работают» в той же директория. По этой причине пользователю важно знать текущую директория `bash`. Для этого служит утилита `pwd`:

.. code-block:: bash

	[user@comp ~]$ pwd
	/home/user
	[user@comp ~]$

Команда `pwd` возвращает полный путь текущей директории `bash`. В данном случае текущей является директория «/home/user».

Утилиты, которые мы рассмотрим далее, по умолчанию читают и создают файлы в текущей директории.

Для вывода содержимого текущей директории испольузется команда `ls`:

.. code-block:: bash

	[user@comp ~]$ ls
	Desktop    Music       Public     Documents  Downloads
	Pictures    Templates
	[user@comp ~]$

Если указать опцию `-a`, можно будет увидеть все файлы, включая скрытые (имена которых начинаются с точки).

.. code-block:: bash

	[user@comp ~]$ ls -a
	.                   ..                .bash_history
	.icons              .bash_logout      .selected_editor
	.bash_profile       .java             .ssh
	.bashrc             .lesshst          Desktop
	.mc                 Templates         Music
	Documents           Downloads         .nano
	.viminfo            Pictures          Public
	[user@comp ~]$


Первая ссылка указывает на текущую папку (.), вторая (..) указывает на папку уровнем выше. Это открывает еще более широкие возможности для навигации по каталогам. 

После самой команды `ls` в качестве ее аргумента можно указать один или более файлов или директорий. Если указать имя файла, то команда `ls` выведет информацию только об этом файле. А если указать название директории, `ls` покажет все ее содержимое. Опция `-l` команды `ls` бывает очень полезной если вы хотите кроме имен файлов узнать более подробную информацию о них (права на файл, имя владельца, время последнего изменения файла и его размер).
В следующем примере показано применение опции `-l` для вывода информации о файлах хранящихся в директории `/usr`

.. code-block:: bash

	[user@comp ~]$ ls -l /usr
	total 276
	drwxr-xr-x   2 root root 131072 Sep  8 21:25 bin
	drwxr-xr-x   2 root root   4096 Sep  6  2016 games
	drwxr-xr-x  48 root root  20480 Sep  4 22:31 include
	drwxr-xr-x 222 root root  69632 Sep  4 23:35 lib
	drwxr-xr-x  10 root root   4096 Oct  7  2010 local
	drwxr-xr-x   3 root root   4096 Aug 19  2016 locale
	drwxr-xr-x   2 root root  12288 Sep  4 23:35 sbin
	drwxr-xr-x 427 root root  20480 Sep  4 23:35 share
	drwxrwsr-x   6 root src    4096 Sep  8 21:25 src
	[user@comp ~]$

В первой колонке показана информация о правах доступа к каждому файлу в списке. Следующая колонка показывает количество ссылок на каждый элемент списка. Третья и четвертая колонки — владелец и группа файла соответственно. Пятая колонка — размер. Шестая — время последнего изменения файла ('last modified time' или mtime). Последняя колонка — имя файла или директории (Если это ссылка, то после знака «–>» стоит имя объекта на который она ссылается).


Иногда возникает потребность посмотреть информацию только о директориях, а не о всем их содержимом. С этой задачей поможет справиться опция `-d`, которая указывает команде выводить информацию только о директориях.

.. code-block:: bash

	[user@comp ~]$ ls -dl /usr
	drwxr-xr-x 11 root root 4096 Aug 19  2016 /usr

Действие опции `-R` противоположно действию `-d`. Она позволяет выводить информацию о файлах находящихся в директории рекурсивно. Сначала показывается содержимое директории верхнего уровня, потом по очереди содержимое всех поддиректорий и так далее. Вывод этой команды может быть достаточно объемным, поэтому мы не приводим ее пример, но вы можете попробовать сделать это самостоятельно, набрав в командной строке `ls -R` или `ls -Rl`.

Команда cd
----------

Для смены текущей директории командного интерпретатора можно воспользоваться командой `cd`. Для этого необходимо набрать команду в виде

.. code-block:: bash

	cd <имя директории>

где <имя директории> – полное или относительное имя директории, которую вы хотите сделать текущей. Команда `cd` без параметров сделает текущей директорией домашнюю директорию пользователя.

В операционной системе Linux может быть несколько видов путей к файлу:

#. Полный, абсолютный путь linux от корня файловой системы — начинается от корня «/» и описывает весь путь к файлу. Например: «/home/user/myfile»
#. Относительный путь linux — это путь к файлу относительно текущей папки. Например (для файла находящегося в родительской папке): «../myfile». 
#. Путь относительно домашний папки текущего пользователя — путь в файловой системе, только не от корня, а от папки текущего пользователя. Чтобы задать путь подобным образом он должен начинаться с «~/». Например: «~/myfile».


Отделить путь к файлу от его имени можно с помощью команд `dirname` и `basename` соответственно:

.. code-block:: bash

	[user@comp ~]$ basename /home/user/somefile
	somefile
	[user@comp ~]$ basename somefile
	somefile
	[user@comp ~]$ dirname /home/user/somefile
	/home/somefile
	[user@comp ~]$ dirname ./somefile
	.
	[user@comp ~]$ dirname somefile
	.
	[user@comp ~]

Заметим, что для «somefile» и «./somefile» `dirname` выдаёт одинаковый результат: «.», что понятно: как было сказано выше, эти формы пути совершенно эквивалентны, а при автоматической обработке результатов dirname гораздо лучше получить «.», чем пустую строку.


Команда mkdir
-------------

Для создания новой поддиректории используется команда `mkdir`. В простейшем виде команда выглядит следующим образом:

.. code-block:: bash

	mkdir <имя_директории>

По умолчанию команда `mkdir` не может создать вложенной структуры директорий. Поэтому, если вам нужно создать несколько вложенных одна в другую директорий (my/super/dir), то вам придется три раза поочередно вызывать эту команду:

.. code-block:: bash

	[user@comp ~]$ mkdir my/super/dir
	mkdir: cannot create directory 'my/super/dir': No such file or directory
 	[user@comp ~]$ mkdir my
	[user@comp ~]$ mkdir my/super
	[user@comp ~]$ mkdir my/super/dir
	[user@comp ~]$ 

Упростить эту операцию можно добавив опцию 	`-p` к команде `mkdir`. Эта опция позволяет создавать вложенную структуру директорий:

.. code-block:: bash

	[user@comp ~]$ mkdir -p my/super/dir
	[user@comp ~]$

Команда cat
-----------

Команда `cat` может быт использована для просмотра содержимого небольшого текстового файла на экране. Если набрать ее в виде

.. code-block:: bash

	cat <имя файла>

то на экран будет выдано все его содержимое.

Не пытайтесь рассматривать на экране содержимое директорий – все равно не получится. Не пытайтесь просматривать содержимое неизвестных файлов, особенно если вы не знаете, текстовый он или бинарный. Вывод на экран бинарного файла может привести к непредсказуемому поведению терминала.

Если даже ваш файл и текстовый, но большой, то все равно вы увидите только его последнюю страницу. Большой текстовый файл удобнее рассматривать с помощью утилиты `more`:

.. code-block:: bash

	more <текстовый файл>

Если мы в качестве параметров для команды `cat` зададим не одно имя, а имена нескольких файлов

.. code-block:: bash

	cat файл1 файл2 ... файлN

то система выдаст на экран их содержимое в указанном порядке. 


Перенаправление ввода-вывода
----------------------------

Вывод команды cat можно перенаправить с экрана терминала в какой-нибудь файл, воспользовавшись символом перенаправления выходного потока данных – знаком "больше" – ">". Команда

.. code-block:: bash

	cat файл1 файл2 ... файлN > <файл результата>

запишет содержимое всех файлов, чьи имена стоят перед знаком ">", воедино в «файл результата» – конкатенирует их. Прием перенаправления выходных данных со стандартного потока вывода (экрана) в файл является стандартным для всех команд, выполняемых командным интерпретатором. Вы можете получить файл, содержащий список всех файлов текущей директории, если выполните команду ls -a с перенаправлением выходных данных

.. code-block:: bash

	ls -a > <новый файл>

Если имена входных файлов для команды `cat` не заданы, то она будет использовать в качестве входных данных информацию, которая вводится с клавиатуры, до тех пор, пока вы не наберете признак окончания ввода – комбинацию клавиш <CTRL> и <d>.

Таким образом, команда

.. code-block:: bash

	cat > <новый файл>

позволяет создать новый текстовый файл с именем «новый файл» и содержимым, которое пользователь введет с клавиатуры. У команды `cat` существует множество различных опций. Посмотреть ее полное описание можно в UNIX Manual.

Заметим, что наряду с перенаправлением выходных данных существует способ перенаправить входные данные. Если во время выполнения некоторой команды требуется ввести данные с клавиатуры, можно положить их заранее в файл, а затем перенаправить стандартный ввод этой команды с помощью знака "меньше" – "<" и следующего за ним имени файла с входными данными.

Перенаправление с помощью ">" перезаписывает соержимое файла заново. Если нужно дописать в конец, то следует воспользоваться ">>".

Например:

.. code-block:: bash

	[user@comp ~]$ ls -a > list.txt
	[user@comp ~]$ ls -a >> list.txt
	[user@comp ~]$

файл `list.txt` будет содержать результат работы обеих запусков команды `ls`.


Shell скрипты
-------------

Команды исполняемые в bash таккже можно записать в файл и запускать на исполнение. Для этого нужно создать файл (как правило с расширением .sh, например script.sh), первой строкой указать интерпретатор который будет исполнять команды, в нашем случае это

.. code-block:: bash

	#! /bin/bash

и далее поместить исполняемые команды.

Например:

.. code-block:: bash

	#! /bin/bash
	pwd
	ls -al

чтобы файл можно было запускать, установим ему атрибут исполнения при помощи команды `chmod` (будет рассмотрена на следующем занятии): 

.. code-block:: bash

	[user@comp ~]$ chmod a+x ./script.sh
	[user@comp ~]$

и далее запустим

.. code-block:: bash

	[user@comp ~]$ ./script.sh
	<результат работы скрипта>
	[user@comp ~]$

В результате работы скрипта на экран сначала будет выведена текущая директория, а потом ее содержимое.

Чтобы программа, вызывающая скрипт могла проанализировать результат его исполнения, существует такое понятие как код возврата, которое доступно вызывающей программе.

Например:

.. code-block:: bash

	[user@comp ~]$ ls
	<содержимое каталога>
	[user@comp ~]$ echo $?
	0
	[user@comp ~]$ 

Нулевой код возврата означает что вызываемая команда (или скрипт) отработали корректно. Попробуем вывести содержимое несуществующей директории:

.. code-block:: bash

	[user@comp ~]$ ls /abc
	ls: /abc: No such file or directory
	[user@comp ~]$ echo $?
	1
	[user@comp ~]$

Как мы видим, в результате команда `ls` вернула код ошибки 1. 

Каждая команда возвращает код завершения (иногда код завершения называют возвращаемым значением ). В случае успеха команда должна возвращать 0, а в случае ошибки -- ненулевое значение, которое, как правило, интерпретируется как код ошибки. Практически все команды и утилиты UNIX возвращают 0 в случае успешного завершения, но имеются и исключения из правил.

Код возврата последней команды хранится в специальной переменной `$?`. После исполнения кода функции, переменная `$?`` хранит код завершения последней команды, исполненной в функции. Таким способом в bash передается "значение, возвращаемое" функцией. После завершения работы сценария, код возврата можно получить, обратившись из командной строки к переменной `$?`, т.е. это будет код возврата последней команды, исполненной в сценарии.

Аналогичным образом ведут себя функции, расположенные внутри сценария, и сам сценарий, возвращая код завершения. Код, возвращаемый функцией или сценарием, определяется кодом возврата последней команды. Команде `exit` можно явно указать код возврата, в виде: `exit nnn`, где `nnn` -- это код возврата (число в диапазоне 0 - 255).

Когда работа сценария завершается командой `exit` без параметров, то код возврата сценария определяется кодом возврата последней исполненной командой.


Редактор vim
------------

Vim (сокр. от Vi Improved, произносится Вим) — текстовый редактор, созданный на основе более старого Vi. Ныне это один из мощнейших текстовых редакторов с полной свободой настройки и автоматизации.

Режимы работы
~~~~~~~~~~~~~

Существует три основных режима работы: режим команд, режим редактирования и режим последней строки. Переход в режим редактирования клавишами `i` или `insert`, выход из режима редактирования осуществляется клавишей `Esc`. Находясь в режиме команд, можно выполнять сложные операции редактирования текста с помощью клавиши "двоеточие"(:). При нажатии этой клавиши курсор устанавливается в последнюю строку экрана, поэтому данный режим называется режимом последней строки. Он считается особым типом режима команд.

Для того, чтобы открыть какой-то файл или создать новый надо выполнить команду:

.. code-block:: bash

	[user@comp ~]$  vi <имя файла>

Затем можно нажать клавишу `i` (или `insert`) и внести нужные изменения.
Если вместо `i` нажать `a`, текст будет вставляться за символом на котором стоит курсор (обычно используется при редактировании файлов этот метод), если нажать `o` - будет вставлена новая строка.

Стирать текст следует выйдя из режима редактирования клавишей `Esc` и затем можно использовать клавишу `x` - она работает как клавиша `del` - стирает вперед, если нажимать `shift+x`, то будет стирать назад (по аналогии с `backspace`)

После редактирования нажмите `(esc):wq` чтобы выйти с сохранением текста.

Более подробно о vim можно прочитать в `учебнике`__. 

.. __: http://rus-linux.net/MyLDP/BOOKS/Vim/prosto-o-vim.pdf


Скрипты командной строки Linux
##############################

:date: 2018-09-16 09:00
:summary: Скрипты командной строки Linux.


.. default-role:: code

Переменные окружения
====================

Переменные окружения в Linux набор пар ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ, которые могут использоваться программами во время выполнения. Удобно, когда программа "угадывает" имя пользователя или домашний каталог пользователя. Чаще всего такая информация "добывается" из переменных окружения USER и HOME соответственно.
Переменные могут определяться системой и пользователем. Системные переменные окружения Linux определяются системой и используются программами системного уровня. Пользовательские переменные окружения устанавливаются пользователем, для текущей оболочки, временно или постоянно. Переменные окружения могут формироваться как из заглавных, так и из строчных символов, однако исторически сложилось именовать их в верхнем регистре. Значение каждой переменной окружения изначально представляет собой строковую константу (строку). 

Командные оболочки, такие как bash, располагают собственным набором пар ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ - это переменные оболочки. Набор таких переменных называют окружением (или средой) оболочки. Эти переменные чем-то напоминают локальные переменные в языке C. Они недоступны для других программ и используются в основном в сценариях оболочки. Чтобы задать переменную оболочки, достаточно написать в командной строке ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ.

Для того, чтобы посмотреть список переменных, определенных в текущей оболочке запустите в терминале команду `set`:

 .. code-block:: bash

	[user@comp ~]$ set | less
	BASH=/bin/bash
	BASH_ALIASES=()
	BASH_ARGC=()
	BASH_ARGV=()
	BASH_CMDS=()
	BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
	BASH_LINENO=()
	BASH_REMATCH=()
	BASH_SOURCE=()
	BASH_VERSINFO=([0]="4" [1]="3" [2]="48" [3]="1" [4]="release" [5]="i686-pc-linux-gnu")
	BASH_VERSION='4.3.48(1)-release'
	CLUTTER_IM_MODULE=xim
	COLUMNS=168
	COMP_WORDBREAKS=$' \t\n"\'><;|&(:'
	DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-ieTFEcTTRm
	DEFAULTS_PATH=/usr/share/gconf/gnome.default.path
	DERBY_HOME=/usr/lib/jvm/java-8-oracle/db
	DESKTOP_SESSION=gnome
	DIRSTACK=()
	DISPLAY=:0
	EUID=1000
	GDMSESSION=gnome
	GDM_LANG=en
	GJS_DEBUG_OUTPUT=stderr
	GJS_DEBUG_TOPICS='JS ERROR;JS LOG'
	GNOME_DESKTOP_SESSION_ID=this-is-deprecated
	GNOME_KEYRING_CONTROL=
	...............
	[user@comp ~]$


Чтобы посмотреть список переменных, доступных другим программам, запустим `env`: 

.. code-block:: bash

	[user@comp ~]$ env | less
	XDG_VTNR=7
	XDG_SESSION_ID=c2
	CLUTTER_IM_MODULE=xim
	XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/user
	COMP_WORDBREAKS=        
	"'><;|&(:
	SESSION=gnome
	GPG_AGENT_INFO=/home/user/.gnupg/S.gpg-agent:0:1
	SHELL=/bin/bash
	TERM=xterm-256color
	XDG_MENU_PREFIX=gnome-
	VTE_VERSION=4205
	DERBY_HOME=/usr/lib/jvm/java-8-oracle/db
	QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1
	GJS_DEBUG_OUTPUT=stderr
	WINDOWID=46137354
	[user@comp ~]$

Другими словами отличие команды `env` от команды `set` заключается в том, что команда `set` выводит список всех переменных окружения, включая те переменные, которые не экспортируются в дочерние командные оболочки.

Чтобы добавить переменную в окружение, нужно исполнить конструкцию ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ:

.. code-block:: bash

	[user@comp ~]$ LOCAL_VAR="Hello World"
	[user@comp ~]$ echo $LOCAL_VAR
	Hello World
	[user@comp ~]$ env | grep LOCAL_VAR
	[user@comp ~]$ set | grep LOCAL_VAR
	'Hello World'
	[user@comp ~]$

Однако, при желании, можно включить локальную переменную оболочки в основное окружение. Для этого используется команда `export`:

.. code-block:: bash

	[user@comp ~]$ export LOCAL_VAR
	[user@comp ~]$ env | grep LOCAL_VAR
	LOCAL_VAR=Hello World
	[user@comp ~]$

Можно сделать сразу так:

.. code-block:: bash

	[user@comp ~]$ export ENV_VAR=Bye
	[user@comp ~]$ echo $ENV_VAR
	Goodbye
	[user@comp ~]$ env | grep ENV_VAR
	ENV_VAR=Bye
	[user@comp ~]$

Интерпретация значений переменных полностью возлагается на программу. Чтобы вывести на экран значение какой-нибудь переменной окружения, достаточно набрать `echo $ИМЯ_ПЕРЕМЕННОЙ`:

.. code-block:: bash

	[user@comp ~]$ echo $USER
	user
	[user@comp ~]$ 

По умолчанию с помощью `env` можно посмотреть все установленные переменные среды. Но с опцией `-i` она позволяет временно удалить все переменные оболочки и выполнить команду без переменных.

.. code-block:: bash

	[user@comp ~]$ env –i [Var=Value] <команда>

Var — это любая переменная, которую вы хотите передать этой команде.

Например, такая команда запустит оболочку вообще без переменных окружения:

.. code-block:: bash

	[user@comp ~]$ env –i bash


После запуска такого окружения, не будет доступно никаких переменных, но после выхода все вернется на свои места.

Существует другой способ удаления переменных окружения Linux - команда unset, удаляет переменную по имени до конца текущей сессии:

.. code-block:: bash

	unset имя_переменной

Например:

.. code-block:: bash

	[user@comp ~]$ export ENV_VAR=Bye
	[user@comp ~]$ echo $ENV_VAR
	Goodbye
	[user@comp ~]$ env | grep ENV_VAR
	ENV_VAR=Bye
	[user@comp ~]$ unset ENV_VAR
	[user@comp ~]$ env | grep ENV_VAR
	[user@comp ~]$


PATH
----

В Linux `$PATH` — это переменная среды, используемая для указания оболочке, где искать исполняемые файлы. `$PATH` обеспечивает большую гибкость и безопасность для систем Linux, и, безусловно, можно сказать, что это одна из самых важных переменных среды.

Программы/скрипты, расположенные в каталоге `$PATH`, могут быть выполнены непосредственно в вашей оболочке без указания полного пути к ним. Посмотрим текущее значение `$PATH`: 

.. code-block:: bash

	[user@comp ~]$ echo $PATH
	/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games/
	[user@comp ~]$ 

В результате выводится список каталогов, разделенных двоеточиями. При осуществлении поиска оболочка просматривает каталоги именно в том порядке, как они перечислены в переменной `PATH`. Чтобы добавить новую директорию необходимо выполнить команду:

.. code-block:: bash

	[user@comp ~]$ PATH=$PATH:<путь к директории>
	или
	[user@comp ~]$ PATH=<путь к директории>:$PATH

В первом случае поиск в добавленной директории будет происходить в последнюю очередь (только если запускаемый файл не найден в директориях, перечисленных в исходном значении `$PATH`), во втором случае - сначала в добавленной директории, а потом в исходном значении `$PATH`.
Отметим, что можно включить в этот список и текущий каталог, добавив в переменную `PATH` точку. Однако этого не рекомендуется делать по соображениям безопасности: злоумышленник может положить в общедоступный каталог команду, имя которой совпадает с одной из часто выполняемых суперпользователем команд, но выполняющую совершенно другие действия (особенно если текущий каталог стоит в начале перечня путей поиска).


Профиль пользователя, права доступа
===================================


Для входа в операционную систему UNIX каждый пользователь должен быть зарегистрирован в ней под определенным именем.  Все пользователи в системе делятся на группы пользователей. Например, все студенты одной учебной группы могут составлять свою собственную группу пользователей. Группы пользователей также получают свои имена.
Для получания информации об активных пользователях сущестует несколько команд:

#. `users` - выводит информацию о пользователях, подключенных к системе данный момент.
#. `w` - список пользователей, подключенных к системе: виртуальный терминал, с которого работает пользователь; время входа в систему для каждого пользователя, статистику использования системы (IDLE - время простоя, JCPU - использование процессора), выполняемые каждым пользователем задачи.
#. `who` - список пользователей, подключенных к системе; время и дату входа каждого пользователя.
#. `whoami` - имя пользования, который ввел команду. 
#. `ps` - выдает информацию об активных процессах. По умолчанию информация дается только о процессах, ассоциированных с данным терминалом. Выводятся идентификатор процесса, идентификатор терминала, истраченное к данному моменту время ЦП и имя команды. Если нужна иная информация, следует вопользоваться опцией `-e`.


Для каждого файла, созданного в файловой системе запоминаются имена его хозяина и группы хозяев. Заметим, что группа хозяев не обязательно должна быть группой, в которую входит хозяин. В операционной системе Linux при создании файла его хозяином становится пользователь, создавший файл, а его группой хозяев - группа, к которой он принадлежит. Впоследствии хозяин файла или системный администратор может передать его в собственность другому пользователю или изменить его группу хозяев с помощью команд `chown` и `chgrp`, описание которых можно найти в UNIX Manual.

Таким образом, для каждого файла выделяется три категории пользователей: 

#. Пользователь, являющийся хозяином файла.

#. Пользователи, относящиеся к группе хозяев файла.

#. Все остальные пользователи.


Для каждой из этих категорий пользователей владелец файла может определить различные права доступа к файлу, используя команду `chmod`. Различают три вида прав доступа: право на чтение файла - r(read), право на модификацию файла - w (write) и право на исполнение файла - x (execute). Для регулярных файлов смысл этих прав совпадает с указанным выше. Для директорий он несколько меняется. Право чтения для каталогов позволяет читать имена файлов, находящихся в этом каталоге (и только имена). Поскольку "исполнять" директорию бессмысленно (как, впрочем, и не исполняемый регулярный файл) право доступа на исполнение для директорий меняет смысл: наличие этого права позволяет получить дополнительную информацию о файлах, входящих в каталог: их размер, кто их хозяин, дата создания и т.д. Право на исполнение также требуется для директории, чтобы сделать ее текущей, а также для всех директорий по пути к указанной. Право записи для директории позволяет изменять ее содержимое: создавать и удалять в ней файлы, переименовывать их. Отметим, что для удаления файла достаточно иметь право записи для директории, в которую непосредственно входит данный файл, независимо от прав доступа к самому файлу. 

chmod
-----

.. code-block:: bash

	[user@comp ~]$ chmod опции права <путь к файлу>

Существует два способа задания прав символьный и числовой. В числовом виде файлу или каталогу устанавливаются абсолютные права, в то же время в символьном виде можно изменить отдельные права для разных типов пользователей.

В символьном виде опции описывают операции, которые нужно совершить над правами пользователей и имеют вид [references][operator][modes].

References определяют пользователей, которым будут меняться права. References определяются одной или несколькими буквами:

#. u (user) - Владелец файла
#. g (group) - Пользователи, входящие в группу владельца файла
#. o (others) - Остальные пользователи
#. a (all) - Все пользователи (или ugo)


Operator определяет операцию, которую будет выполнять `chmod`:

#. \+ - добавить определенные права
#. \- - удалить определенные права
#. = - установить определенные права

Modes определяет какие именно права будут установлены, добавлены или удалены:

#. r (read) -чтение файла или содержимого каталога
#. w (write) - запись в файл или в каталог
#. x (execute) - выполнение файла или чтение содержимого каталога

Например:

Установить права на чтение и выполнение для владельца файла, удалить права на выполнение у группы, удалить права на запись и выполнение у остальных пользователей:

.. code-block:: bash

	[user@comp ~]$ chmod u+rx,g-x,o-wx <filename>

В числовом виде, права задаются в виде трехзначного числа, каждая цифра которого задает права файла для определенной категории пользователей - первая для владельца, вторая - группы, третья - остальных.

Варианты записи прав пользователя

+----------+--------------+------------+
| двоичная | восьмеричная | символьная |
+----------+--------------+------------+
| 000      | 0            | ---        |
+----------+--------------+------------+
| 001      | 1            | --x        |
+----------+--------------+------------+
| 010      | 2            | -w-        |
+----------+--------------+------------+
| 011      | 3            | -wx        |
+----------+--------------+------------+
| 100      | 4            | r--        |
+----------+--------------+------------+
| 101      | 5            | r-x        |
+----------+--------------+------------+
| 110      | 6            | rw-        |
+----------+--------------+------------+
| 111      | 7            | rwx        |
+----------+--------------+------------+


Таким образом, `chmod 755 filename` означает права `rwxr-xr-x`:

+-------------------------------+----------+--------+-----------+
|                               | владелец | группа | остальные |
+===============================+==========+========+===========+
| восьмеричное значение         | 7        | 5      | 5         |
+-------------------------------+----------+--------+-----------+
| символьная запись             | rwx      | r-x    | r-x       |
+-------------------------------+----------+--------+-----------+
| обозначение типа пользователя | u        | g      | o         |
+-------------------------------+----------+--------+-----------+

Распространенные значения:

400 (-r--------). Владелец имеет право чтения; никто другой не имеет права выполнять никакие действия.

644 (-rw-r--r--). Все пользователи имеют право чтения; владелец может редактировать.

660 (-rw-rw----). Владелец и группа могут читать и редактировать; остальные не имеют права выполнять никаких действий.

664 (-rw-rw-r--). Все пользователи имеют право чтения; владелец и группа могут редактировать.

666 (-rw-rw-rw-). Все пользователи могут читать и редактировать.

700 (-rwx------). Владелец может читать, записывать и запускать на выполнение; никто другой не имеет права выполнять никакие действия.

744 (-rwxr--r--). Каждый пользователь может читать, владелец имеет право редактировать и запускать на выполнение.

755 (-rwxr-xr-x). Каждый пользователь имеет право читать и запускать на выполнение; владелец может редактировать.

777 (-rwxrwxrwx). Каждый пользователь может читать, редактировать и запускать на выполнение.


foreground и background процессы
--------------------------------

Запущенный процесс в обычном режиме работает в режиме “foreground“, т.е. – “на переднем плане” или, другими словами, “в приоритетном режиме”. В таком режиме он принимает команды с управляющего терминала, в котором он запущен, и на него же выводит информацию `stdout` и `stderr`. Кроме того, он делает недоступным командную строку.

Что бы запустить задачу в фоновом режиме – в конце команды необходимо добавить знак &, например:


.. code-block:: bash

	[user@comp ~]$ tar cpf usr.lib.tar usr/lib 2>/dev/null &
	[1] 55887
	[user@comp ~]$

Отобразить список текущих фоновых задач можно командой `jobs`, например:

.. code-block:: bash

	[user@comp ~]$  jobs
	[6]-  Stopped                 top
	[7]+  Stopped                 tar


Второй способ – запустить её в обычном режиме, после чего нажать комбинацию ctrl+Z. После этого – она появится в списке jobs с новым номером:

.. code-block:: bash

	[user@comp ~]$ tar cpf usr.lib.tar usr/lib 2>/dev/null
	^Z
	[2]+  Stopped                 tar cpf usr.lib.tar usr/lib 2>/dev/null &
	[user@comp ~]$


Теперь, что бы продолжить её выполнение в фоновом режиме – введите команду `bg` (background):

.. code-block:: bash

	[user@comp ~]$ bg
	[2]+      tar cpf usr.lib.tar usr/lib 2>/dev/null &


Команда `jobs` всегда вызывается без аргументов и показывает задания, запущенные из текущего экземпляра оболочки. В начале каждой строки вывода этой команды указывается порядковый номер задания в виде числа в квадратных скобках. После номера указывается состояние процесса: stopped (остановлен), running (выполняется) или suspended (приостановлен). В конце строки указывается команда, которая исполняется данным процессом. Один из номеров выполняющихся заданий помечен знаком +, а еще один — знаком -. Процесс, помеченный знаком +, будет по умолчанию считаться аргументом команд `fg` или `bg`, если они вызываются без параметров. Процесс, помеченный знаком -, получит знак +, если только завершится по какой-либо причине процесс, который был помечен знаком +.

Что бы вывести задачу из фонового режима – используется команда `fg` (foreground), которой можно либо передать номер задачи в качестве аргумента, либо – запустить без аргументов. В последнем случае – будет выведена задача, отмеченная знаком + в списке jobs, т.е. – последняя отправленная “в фон” задача.

Например, команда (в случае если `top` находится в фоновом режиме с номером задачи 6) :

.. code-block:: bash

	[user@comp ~]$ fg 6


Вернёт на экран утилиту `top` и переведёт её в режим Running.



Cигналы и команда kill
----------------------

Сигналы — это средство, с помощью которого процессам можно передать сообщения о некоторых событиях в системе. Сами процессы тоже могут генерировать сигналы, с помощью которых они передают определенные сообщения ядру и другим процессам. С помощью сигналов можно осуществлять такие акции управления процессами, как приостановка процесса, запуск приостановленного процесса, завершение работы процесса. Всего в Linux существует 63 разных сигнала, их перечень можно посмотреть по команде

.. code-block:: bash

	[user@comp ~]$ kill –l

Сигналы принято обозначать номерами или символическими именами. Все имена начинаются на SIG, но эту приставку иногда опускают: например, сигнал с номером 1 обозначают или как SIGHUP, или просто как HUP.

Когда процесс получает сигнал, то возможен один из двух вариантов развития событий. Если для данного сигнала определена подпрограмма обработки, то вызывается эта подпрограмма. В противном случае ядро выполняет от имени процесса действие, определенное по умолчанию для данного сигнала. Вызов подпрограммы обработки называется перехватом сигнала. Когда завершается выполнение подпрограммы обработки, процесс возобновляется с той точки, где был получен сигнал.

Можно заставить процесс игнорировать или блокировать некоторые сигналы. Игнорируемый сигнал просто отбрасывается процессом и не оказывает на него никакого влияния. Блокированный сигнал ставится в очередь на выдачу, но ядро не требует от процесса никаких действий до разблокирования сигнала. После разблокирования сигнала программа его обработки вызывается только один раз, даже если в течение периода блокировки данный сигнал поступал несколько раз.

Списрк некоторых из часто встречающихся сигналов.

|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
| №  | Имя  |                                    Описание                                    |     Можно     |    Можно    | Комбинация |
|    |      |                                                                                | перехватывать | блокировать |   клавиш   |
|====|======|================================================================================|===============|=============|============|
|  1 | HUP  | Cигнал, посылаемый процессу для уведомления                                    | Да            | Да          |            |
|    |      | о потере соединения с управляющим терминалом пользователя                      |               |             |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
|  2 | INT  | Interrupt. В случае выполнения простых команд вызывает прекращение выполнения, | Да            | Да          | <Ctrl>+<C> |
|    |      | в интерактивных программах — прекращение активного процесса                    |               |             | или <Del>  |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
|  3 | QUIT | Сигнал, для остановки процесса пользователем. Также указывает,                 | Да            | Да          | <Ctrl>+<\> |
|    |      | что система должна выполнить дамп памяти для процесса                          |               |             |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
|  4 | ILL  | Illegal Instruction. Центральный процессор столкнулся с                        | Да            | Да          |            |
|    |      | незнакомой командой (в большинстве случаев это означает,                       |               |             |            |
|    |      | что допущена программная ошибка). Сигнал отправляется программе,               |               |             |            |
|    |      | в которой возникла проблема                                                    |               |             |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
|  8 | FPE  | Floating Point Exception. Вычислительная ошибка, например,                     | Да            | Да          |            |
|    |      | деление на ноль                                                                |               |             |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
|  9 | KILL | Всегда прекращает выполнение процесса                                          | Нет           | Нет         |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
| 11 | SEGV | Segmentation Violation. Доступ к недозволенной области памяти                  | Да            | Да          |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
| 15 | TERM | Software Termination. Требование закончить процесс (программное завершение)    | Да            | Да          |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
| 17 | CHLD | Изменение статуса порожденного процесса                                        | Да            | Да          |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
| 18 | CONT | Продолжение выполнения приостановленного процесса                              | Да            | Да          |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
| 19 | STOP | Приостановка выполнения процесса                                               | Нет           | Нет         |            |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|
| 20 | TSTR | Сигнал останова, генерируемый клавиатурой. Переводит процесс в фоновый режим   | Да            | Да          | <Ctrl>+<Z> |
|----|------|--------------------------------------------------------------------------------|---------------|-------------|------------|

Как видно из описания, некоторые сигналы можно сгенерировать с помощью определенных комбинаций клавиш. Но такие комбинации существуют не для всех сигналов. Зато имеется команда kill, которая позволяет послать заданному процессу любой сигнал. Как уже было сказано, с помощью этой команды можно получить список всех возможных сигналов, если указать опцию -l. Если после этой опции указать номер сигнала, то будет выдано его символическое имя, а если указать имя, то получим соответствующий номер.

Для посылки сигнала процессу (или группе процессов) можно воспользоваться командой `kill` в следующем формате:

.. code-block:: bash

	[user]$ kill [-сигн] PID [PID..]

где сигн — это номер сигнала, причем если указание сигнала опущено, то посылается сигнал 15 (`TERM` — программное завершение процесса). Чаще всего используется сигнал 9 (`KILL`), с помощью которого суперпользователь может завершить любой процесс. Но сигнал этот очень "грубый", если можно так выразиться, поэтому его использование может привести к нарушению порядка в системе. Поэтому в большинстве случаев рекомендуется использовать сигналы TERM или QUIT, которые завершают процесс более "мягко".

Естественно, что наиболее часто команду `kill` вынужден применять суперпользователь. Он должен использовать ее для уничтожения процессов-зомби, зависших процессов (они показываются в листинге команды `ps` как <exiting>), процессов, которые занимают слишком много процессорного времени или слишком большой объем памяти и т. д. 


Самостоятельная работа
======================

#. Напишите скрипт `absolute.sh`, который в независимости от того, в какой директории запущен, создает файл `/tmp/hello world/absolute.txt`, содержащий текст 'hello world!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.
#. Напишите скрипт `home.sh`, который в независимости от того, в какой директории запущен, создает файл `<домашняя директория пользователя>/hello home/home.txt`, содержащий текст 'hello home!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.
#. Напишите скрипт `current.sh`, который в независимости от того, в какой директории запущен, создает файл `<текущая директория>/hello current/current.txt`, содержащий текст 'hello current!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.
#. Напишите скрипт `parent.sh`, который в независимости от того, в какой директории запущен, создает файл `<родительская директория>/hello parent/parent.txt`, содержащий текст 'hello parent!!', выводит на экран его содержимое и атрибуты. Запустите скрипт.
#. Напишите скрипт `hello.sh`, который при запуске печатает на экран строку "Hello world!" и сохраните его на рабочем столе.
#. Модифицируйте переменную окружения `PATH` так, чтобы скрипт `hello.sh` можно было запускать командой `hello.sh` из любой текущей директории.
#. Напишите и запустите скрипт `pause.sh`, содержащий внутри себя команду `sleep 1000` ("заснуть" на 1000 сек).
#. Переведите процесс в фоновый режим одним из способов, описанных выше.
#. Определите PID процесса и отправьте ему сигнал SIGKILL.

