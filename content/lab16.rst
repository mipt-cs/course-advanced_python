``NumPy``: матрицы и операции над ними
######################################

:date: 2022-02-08 09:00
:summary: Библиотека NumPy
:status: published

.. default-role:: code
.. role:: python(code)
   :language: python

.. contents::

``NumPy``: матрицы и операции над ними
--------------------------------------

Ссылка на `jupyter notebook`__

__ {filename}/extra/lab14/2Numpy.ipynb

В этом ноутбуке из сторонних библиотек нам понадобится только ``NumPy``.
Для удобства импортируем ее под более коротким именем:

.. code:: python

    import numpy as np

1. Создание матриц
------------------

Приведем несколько способов создания матриц в ``NumPy``.

Самый простой способ — с помощью функции
**numpy.array(list, dtype=None, ...)**.

В качестве первого аргумента ей надо передать итерируемый объект,
элементами которого являются другие итерируемые объекты одинаковой длины
и содержащие данные одинакового типа.

Второй аргумент является опциональным и определяет тип данных матрицы.
Его можно не задавать, тогда тип данных будет определен из типа
элементов первого аргумента. При задании этого параметра будет
произведена попытка приведения типов.

Например, матрицу из списка списков целых чисел можно создать следующим
образом:

.. code:: python

    a = np.array([1, 2, 3])   # Создаем одномерный массив
    print(type(a))            # Prints "<class 'numpy.ndarray'>"
    print(a.shape)            # Prints "(3,)" - кортеж с размерностями
    print(a[0], a[1], a[2])   # Prints "1 2 3"
    a[0] = 5                  # Изменяем значение элемента массива
    print(a)                  # Prints "[5, 2, 3]"

    b = np.array([[1,2,3],[4,5,6]])    # Создаем двухмерный массив
    print(b.shape)                     # Prints "(2, 3)"
    print(b[0, 0], b[0, 1], b[1, 0])   # Prints "1 2 4"
    print(np.arange(1, 5)) #Cоздает вектор с эелементами от 1 до 4


.. parsed-literal::

    <class 'numpy.ndarray'>
    (3,)
    1 2 3
    [5 2 3]
    (2, 3)
    1 2 4
    [1 2 3 4]


.. code:: python

    matrix = np.array([[1, 2, 3], [2, 5, 6], [6, 7, 4]])
    print ("Матрица:\n", matrix)


.. parsed-literal::

    Матрица:
     [[1 2 3]
     [2 5 6]
     [6 7 4]]


Второй способ создания — с помощью встроенных функций
**numpy.eye(N, M=None, ...)**, **numpy.zeros(shape, ...)**,
**numpy.ones(shape, ...)**.

Первая функция создает единичную матрицу размера :math:`N \times M`;
если :math:`M` не задан, то :math:`M = N`.

Вторая и третья функции создают матрицы, состоящие целиком из нулей или
единиц соответственно. В качестве первого аргумента необходимо задать
размерность массива — кортеж целых чисел. В двумерном случае это набор
из двух чисел: количество строк и столбцов матрицы.

**Примеры:**

.. code:: python

    b = np.eye(5)
    print ("Единичная матрица:\n", b)


.. parsed-literal::

    Единичная матрица:
     [[1. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0.]
     [0. 0. 1. 0. 0.]
     [0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 1.]]


.. code:: python

    c = np.ones((7, 5))
    print ("Матрица, состоящая из одних единиц:\n", c)


.. parsed-literal::

    Матрица, состоящая из одних единиц:
     [[1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]]


.. code:: python

    d = np.full((2,2), 7)  # Создает матрицу (1, 2) заполненую заданным значением
    print(d)               # Prints "[[ 7.  7.]
                           #          [ 7.  7.]]"

    e = np.random.random((2,2))  # Создает еденичную матрицу (2, 2) заполненую случаными числами (0, 1)
    print(e)                     # Might print "[[ 0.91940167  0.08143941]
                                 #               [ 0.68744134  0.87236687]]"


.. parsed-literal::

    [[7 7]
     [7 7]]
    [[0.25744383 0.48056466]
     [0.13767881 0.40578168]]


**Обратите внимание: размерность массива задается не двумя аргументами
функции, а одним — кортежем!**

Вот так — **np.ones(7, 5)** — создать массив не получится, так как
функции в качестве параметра ``shape`` передается ``7``, а не кортеж
``(7, 5)``.

И, наконец, третий способ — с помощью функции
**numpy.arange([start, ]stop, [step, ], ...)**, которая создает
одномерный массив последовательных чисел из промежутка
**[start, stop)** с заданным шагом **step**, и *метода*
**array.reshape(shape)**.

Параметр **shape**, как и в предыдущем примере, задает размерность
матрицы (кортеж чисел). Логика работы метода ясна из следующего примера:

.. code:: python

    v = np.arange(0, 24, 2)
    print ("Вектор-столбец:\n", v)


.. parsed-literal::

    Вектор-столбец:
     [ 0  2  4  6  8 10 12 14 16 18 20 22]


.. code:: python

    d = v.reshape((3, 4))
    print ("Матрица:\n", d)


.. parsed-literal::

    Матрица:
     [[ 0  2  4  6]
     [ 8 10 12 14]
     [16 18 20 22]]


Более подробно о том, как создавать массивы в ``NumPy``, см.
`документацию <http://docs.scipy.org/doc/numpy-1.10.1/user/basics.creation.html>`__.

2. Индексирование
-----------------

Для получения элементов матрицы можно использовать несколько способов.
Рассмотрим самые простые из них.

Для удобства напомним, как выглядит матрица **d**:

.. code:: python

    print ("Матрица:\n", d)


.. parsed-literal::

    Матрица:
     [[ 0  2  4  6]
     [ 8 10 12 14]
     [16 18 20 22]]


Элемент на пересечении строки **i** и столбца **j** можно
получить с помощью выражения **array[i, j]**.

**Обратите внимание:** строки и столбцы нумеруются с нуля!

.. code:: python

    print ("Второй элемент третьей строки матрицы:", d[2, 1])


.. parsed-literal::

    Второй элемент третьей строки матрицы: 18


Из матрицы можно получать целые строки или столбцы с помощью выражений
**array[i, :]** или **array[:, j]** соответственно:

.. code:: python

    print ("Вторая строка матрицы d:\n", d[1, :])
    print ("Четвертый столбец матрицы d:\n", d[:, 3])


.. parsed-literal::

    Вторая строка матрицы d:
     [ 8 10 12 14]
    Четвертый столбец матрицы d:
     [ 6 14 22]


Еще один способ получения элементов — с помощью выражения
**array[list1, list2]**, где **list1**, **list2** —
некоторые списки целых чисел. При такой адресации одновременно
просматриваются оба списка и возвращаются элементы матрицы с
соответствующими координатами. Следующий пример более понятно объясняет
механизм работы такого индексирования:

.. code:: python

    print ("Элементы матрицы d с координатами (1, 2) и (0, 3):\n", d[[1, 0], [2, 3]])


.. parsed-literal::

    Элементы матрицы d с координатами (1, 2) и (0, 3):
     [12  6]


.. code:: python

    # Slicing

    # Создадим матрицу (3, 4)
    # [[ 1  2  3  4]
    #  [ 5  6  7  8]
    #  [ 9 10 11 12]]
    a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

    # Используя слайсинг, созадим матрицу b из элементов матрицы а
    # будем использовать 0 и 1 строку, а так же 1 и 2 столебц
    # [[2 3]
    #  [6 7]]
    b = a[:2, 1:3]
    print(b)

    # ОБРАТИТЕ ВНИМАНИЕ НА ИЗМЕНЕНИЕ ИСХОДОЙ МАТРИЦЫ
    print(a[0, 1])   # Prints "2"
    b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]
    print(a[0, 1])   # Prints "77"


.. parsed-literal::

    [[2 3]
     [6 7]]
    2
    77


.. code:: python

    # Integer array indexing

    a = np.array([[1,2], [3, 4], [5, 6]])
    print(a)
    print()

    # Пример Integer array indexing
    # В результате получится массив размерности (3,)
    # Обратите внимание, что до запятой идут индексы строк, после - столбцов
    print(a[[0, 1, 2], [0, 1, 0]])  # Prints "[1 4 5]"
    print()

    # По-другому пример можно записать так
    print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints "[1 4 5]"


.. parsed-literal::

    [[1 2]
     [3 4]
     [5 6]]

    [1 4 5]

    [1 4 5]


Примеры использования слайсинга:

.. code:: python


    # Создадим новый маассив, из которого будем выбирать эллементы
    a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

    print(a)  # prints "array([[ 1,  2,  3],
              #                [ 4,  5,  6],
              #                [ 7,  8,  9],
              #                [10, 11, 12]])"

    # Создадим массив индексов
    b = np.array([0, 2, 0, 1])

    # Выберем из каждой строки элемент с индексом из b (индекс столбца берется из b)
    print(a[np.arange(4), b])  # Prints "[ 1  6  7 11]"
    print()

    # Добавим к этим элементам 10
    a[np.arange(4), b] += 10

    print(a)  # prints "array([[11,  2,  3],
              #                [ 4,  5, 16],
              #                [17,  8,  9],
              #                [10, 21, 12]])


.. parsed-literal::

    [[ 1  2  3]
     [ 4  5  6]
     [ 7  8  9]
     [10 11 12]]
    [ 1  6  7 11]

    [[11  2  3]
     [ 4  5 16]
     [17  8  9]
     [10 21 12]]


.. code:: python

    a = np.array([[1,2], [3, 4], [5, 6]])

    bool_idx = (a > 2)   # Найдем эллементы матрицы a, которые больше 2
                         # В результате получим матрицу b, такой же размерности, как и a

    print(bool_idx)      # Prints "[[False False]
    print()              #          [ True  True]
                         #          [ True  True]]"

    # Воспользуемся полученным массивом для создания нового массива, ранга 1
    print(a[bool_idx])  # Prints "[3 4 5 6]"

    # Аналогично
    print(a[a > 2])     # Prints "[3 4 5 6]"


.. parsed-literal::

    [[False False]
     [ True  True]
     [ True  True]]

    [3 4 5 6]
    [3 4 5 6]


.. code:: python

    #Помните, что вы можете пользоваться сразу несколькими типами индексирования
    a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

    row_r1 = a[1, :]
    row_r2 = a[1:2, :]
    print(row_r1, row_r1.shape)  # Prints "[5 6 7 8] (4,)"
    print(row_r2, row_r2.shape)  # Prints "[[5 6 7 8]] (1, 4)"


.. parsed-literal::

    [5 6 7 8] (4,)
    [[5 6 7 8]] (1, 4)


Более подробно о различных способах индексирования в массивах см.
`документацию <http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html>`__.

3. Векторы, вектор-строки и вектор-столбцы
------------------------------------------

Следующие два способа задания массива кажутся одинаковыми:

.. code:: python

    a = np.array([1, 2, 3])
    b = np.array([[1], [2], [3]])

Однако, на самом деле, это задание одномерного массива (то есть
*вектора*) и двумерного массива:

.. code:: python

    print ("Вектор:\n", a)
    print ("Его размерность:\n", a.shape)
    print ("Двумерный массив:\n", b)
    print ("Его размерность:\n", b.shape)


.. parsed-literal::

    Вектор:
     [1 2 3]
    Его размерность:
     (3,)
    Двумерный массив:
     [[1]
     [2]
     [3]]
    Его размерность:
     (3, 1)


**Обратите внимание:** *вектор* (одномерный массив) и *вектор-столбец*
или *вектор-строка* (двумерные массивы) являются различными объектами в
``NumPy``, хотя математически задают один и тот же объект. В случае
одномерного массива кортеж **shape** состоит из одного числа и имеет
вид **(n,)**, где **n** — длина вектора. В случае двумерных
векторов в **shape** присутствует еще одна размерность, равная
единице.

В большинстве случаев неважно, какое представление использовать, потому
что часто срабатывает приведение типов. Но некоторые операции не
работают для одномерных массивов. Например, транспонирование (о нем
пойдет речь ниже):

.. code:: python

    a = a.T
    b = b.T

.. code:: python

    print ("Вектор не изменился:\n", a)
    print ("Его размерность также не изменилась:\n", a.shape)
    print ("Транспонированный двумерный массив:\n", b)
    print ("Его размерность изменилась:\n", b.shape)


.. parsed-literal::

    Вектор не изменился:
     [1 2 3]
    Его размерность также не изменилась:
     (3,)
    Транспонированный двумерный массив:
     [[1 2 3]]
    Его размерность изменилась:
     (1, 3)


4. Datatypes
------------

Все элементы в массиве numpy принадлежат одному типу. В этом плане
массивы ближе к C, чем к привычным вам листам питона. Numpy имеет
множество встренных типов, подходящих для решения большинства задач.

.. code:: python

    x = np.array([1, 2])   # Автоматический выбор типа
    print(x.dtype)         # Prints "int64"

    x = np.array([1.0, 2.0])   # Автоматический выбор типа
    print(x.dtype)             # Prints "float64"

    x = np.array([1, 2], dtype=np.int64)   # Принудительное выставление типа
    print(x.dtype)                         # Prints "int64"


.. parsed-literal::

    int32
    float64
    int64


5. Математические операции
--------------------------

К массивам (матрицам) можно применять известные вам математические
операции. Следут понимать, что при этом у элементов должны быть схожие
размерности. Поведение в случае не совпадения размерностей хорошо
описанно в документации numpy.

.. code:: python

    x = np.array([[1,2],[3,4]], dtype=np.float64)
    y = np.array([[5,6],[7,8]], dtype=np.float64)
    arr = np.array([1, 2])

.. code:: python

    # Сложение происходит поэлеметно

    # [[ 6.0  8.0]
    #  [10.0 12.0]]
    print(x + y)
    print()
    print(np.add(x, y))
    print('С числом')
    print(x + 1)
    print('C массивом другой размерности')
    print(x + arr)


.. parsed-literal::

    [[ 6.  8.]
     [10. 12.]]

    [[ 6.  8.]
     [10. 12.]]
    С числом
    [[2. 3.]
     [4. 5.]]
    C массивом другой размерности
    [[2. 4.]
     [4. 6.]]


.. code:: python

    # Вычитание
    print(x - y)
    print(np.subtract(x, y))


.. parsed-literal::

    [[-4. -4.]
     [-4. -4.]]
    [[-4. -4.]
     [-4. -4.]]


.. code:: python

    # Деление
    # [[ 0.2         0.33333333]
    #  [ 0.42857143  0.5       ]]
    print(x / y)
    print(np.divide(x, y))


.. parsed-literal::

    [[0.2        0.33333333]
     [0.42857143 0.5       ]]
    [[0.2        0.33333333]
     [0.42857143 0.5       ]]


.. code:: python

    # Другие функции
    # [[ 1.          1.41421356]
    #  [ 1.73205081  2.        ]]
    print(np.sqrt(x))


.. parsed-literal::

    [[1.         1.41421356]
     [1.73205081 2.        ]]


6. Умножение матриц и столбцов
------------------------------

**Напоминание теории.** Операция **умножения** определена для двух
матриц, таких что число столбцов первой равно числу строк второй.

Пусть матрицы :math:`A` и :math:`B` таковы, что
:math:`A \in \mathbb{R}^{n \times k}` и
:math:`B \in \mathbb{R}^{k \times m}`. **Произведением** матриц
:math:`A` и :math:`B` называется матрица :math:`C`, такая что
:math:`c_{ij} = \sum_{r=1}^{k} a_{ir}b_{rj}`, где :math:`c_{ij}` —
элемент матрицы :math:`C`, стоящий на пересечении строки с номером
:math:`i` и столбца с номером :math:`j`.

В ``NumPy`` произведение матриц вычисляется с помощью функции
**numpy.dot(a, b, ...)** или с помощью *метода*
**array1.dot(array2)**, где **array1** и **array2** —
перемножаемые матрицы.

.. code:: python

    a = np.array([[1, 0], [0, 1]])
    b = np.array([[4, 1], [2, 2]])
    r1 = np.dot(a, b)
    r2 = a.dot(b)

.. code:: python

    print ("Матрица A:\n", a)
    print ("Матрица B:\n", b)
    print ("Результат умножения функцией:\n", r1)
    print ("Результат умножения методом:\n", r2)


.. parsed-literal::

    Матрица A:
     [[1 0]
     [0 1]]
    Матрица B:
     [[4 1]
     [2 2]]
    Результат умножения функцией:
     [[4 1]
     [2 2]]
    Результат умножения методом:
     [[4 1]
     [2 2]]


Матрицы в ``NumPy`` можно умножать и на векторы:

.. code:: python

    c = np.array([1, 2])
    r3 = b.dot(c)

.. code:: python

    print ("Матрица:\n", b)
    print ("Вектор:\n", c)
    print ("Результат умножения:\n", r3)


.. parsed-literal::

    Матрица:
     [[4 1]
     [2 2]]
    Вектор:
     [1 2]
    Результат умножения:
     [6 6]


**Обратите внимание:** операция ***** производит над матрицами
покоординатное умножение, а не матричное!

.. code:: python

    r = a * b

.. code:: python

    print ("Матрица A:\n", a)
    print ("Матрица B:\n", b)
    print ("Результат покоординатного умножения через операцию умножения:\n", r)


.. parsed-literal::

    Матрица A:
     [[1 0]
     [0 1]]
    Матрица B:
     [[4 1]
     [2 2]]
    Результат покоординатного умножения через операцию умножения:
     [[4 0]
     [0 2]]


Более подробно о матричном умножении в ``NumPy`` см.
`документацию <http://docs.scipy.org/doc/numpy-1.10.0/reference/routines.linalg.html#matrix-and-vector-products>`__.

7. Объединение массивов
-----------------------

Массивы можно Объединенять. Есть горизонтальное и вертикальное
объединение.

.. code:: python

    a = np.floor(10*np.random.random((2,2)))
    b = np.floor(10*np.random.random((2,2)))

    print(a)
    print(b)
    print()


    print(np.vstack((a,b)))
    print()

    print(np.hstack((a,b)))


.. parsed-literal::

    [[4. 0.]
     [1. 4.]]
    [[9. 7.]
     [2. 6.]]

    [[4. 0.]
     [1. 4.]
     [9. 7.]
     [2. 6.]]

    [[4. 0. 9. 7.]
     [1. 4. 2. 6.]]


Массивы можно переформировать при помощи метода, который задает новый
многомерный массив. Следуя следующему примеру, мы переформатируем
одномерный массив из десяти элементов во двумерный массив, состоящий из
пяти строк и двух столбцов:

.. code:: python

    a = np.array(range(10), float)
    print(a)
    print()

    # Превратим в матрицу
    a = a.reshape((5, 2))
    print(a)
    print()

    # Вернем обратно
    print(a.flatten())

    # Другой вариант
    print(a.reshape((-1)))
    # Превратим в марицу (9, 1)
    print(a.reshape((-1, 1)))
    # Превратим в марицу (1, 9)
    print(a.reshape((1, -1)))


.. parsed-literal::

    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]

    [[0. 1.]
     [2. 3.]
     [4. 5.]
     [6. 7.]
     [8. 9.]]

    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
    [[0.]
     [1.]
     [2.]
     [3.]
     [4.]
     [5.]
     [6.]
     [7.]
     [8.]
     [9.]]
    [[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]]


Задания: (Блок 1)
=================

Задание 1:
~~~~~~~~~~

Решите без использования циклов средставми NumPy (каждый пункт решается
в 1-2 строчки)

1. Создайте вектор с элементами от 12 до 42
2. Создайте вектор из нулей длины 12, но его пятый елемент должен быть равен 1
3. Создайте матрицу (3, 3), заполненую от 0 до 8
4. Найдите все положительные числа в np.array([1,2,0,0,4,0])
5. Умножьте матрицу размерности (5, 3) на (3, 2)
6. Создайте матрицу (10, 10) так, чтобы на границе были 0, а внтури 1
7. Создайте рандомный вектор и отсортируйте его
8. Каков эквивалент функции enumerate для numpy массивов?
9. \*Создайте рандомный вектор и выполните нормализацию столбцов (из каждого столбца вычесть среднее этого столбца, из каждого столбца вычесть sd этого столбца)
10. \*Для заданного числа найдите ближайший к нему элемент в векторе
11. \*Найдите N наибольших значений в векторе

.. code:: python

    # ваш код здесь

Задание 2:
~~~~~~~~~~

| **Напишите полностью векторизованный вариант**
| Дан трёхмерный массив, содержащий изображение, размера (height, width,
  numChannels), а также вектор длины numChannels. Сложить каналы
  изображения с указанными весами, и вернуть результат в виде матрицы
  размера (height, width). Считать реальное изображение можно при помощи
  функции ``scipy.misc.imread`` (если изображение не в формате png,
  установите пакет pillow: ``conda install pillow``). Преобразуйте
  цветное изображение в оттенки серого, использовав коэффициенты
  np.array([0.299, 0.587, 0.114]).

.. code:: python

    # ваш код здесь

8. Транспонирование матриц
--------------------------

**Напоминание теории.** **Транспонированной матрицей** :math:`A^{T}`
называется матрица, полученная из исходной матрицы :math:`A` заменой
строк на столбцы. Формально: элементы матрицы :math:`A^{T}` определяются
как :math:`a^{T}_{ij} = a_{ji}`, где :math:`a^{T}_{ij}` — элемент
матрицы :math:`A^{T}`, стоящий на пересечении строки с номером :math:`i`
и столбца с номером :math:`j`.

В ``NumPy`` транспонированная матрица вычисляется с помощью функции
**numpy.transpose()** или с помощью *метода* **array.T**, где
**array** — нужный двумерный массив.

.. code:: python

    a = np.array([[1, 2], [3, 4]])
    b = np.transpose(a)
    c = a.T

.. code:: python

    print ("Матрица:\n", a)
    print ("Транспонирование функцией:\n", b)
    print ("Транспонирование методом:\n",  c)


.. parsed-literal::

    Матрица:
     [[1 2]
     [3 4]]
    Транспонирование функцией:
     [[1 3]
     [2 4]]
    Транспонирование методом:
     [[1 3]
     [2 4]]


См. более подробно о
`numpy.transpose() <http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.transpose.html>`__
и
`array.T <http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.ndarray.T.html>`__
в ``NumPy``.

В следующих разделах активно используется модуль **numpy.linalg**,
реализующий некоторые приложения линейной алгебры. Более подробно о
функциях, описанных ниже, и различных других функциях этого модуля можно
посмотреть в его
`документации <http://docs.scipy.org/doc/numpy-1.10.0/reference/routines.linalg.html#linear-algebra-numpy-linalg>`__.

9. Определитель матрицы
-----------------------

**Напоминание теории.** Для квадратных матриц существует понятие
**определителя**.

Пусть :math:`A` — квадратная матрица. **Определителем** (или
**детерминантом**) матрицы :math:`A \in \mathbb{R}^{n \times n}` назовем
число

.. math::

   \det A = \sum_{\alpha_{1}, \alpha_{2}, \dots, \alpha_{n}} (-1)^{N(\alpha_{1}, \alpha_{2}, \dots, \alpha_{n})} \cdot a_{\alpha_{1} 1} \cdot \cdot \cdot a_{\alpha_{n} n},

где :math:`\alpha_{1}, \alpha_{2}, \dots, \alpha_{n}` — перестановка
чисел от :math:`1` до :math:`n`,
:math:`N(\alpha_{1}, \alpha_{2}, \dots, \alpha_{n})` — число инверсий в
перестановке, суммирование ведется по всем возможным перестановкам длины
:math:`n`.

*Не стоит расстраиваться, если это определение понятно не до конца — в
дальнейшем в таком виде оно не понадобится.*

Например, для матрицы размера :math:`2 \times 2` получается:

.. math::

   \det \left( \begin{array}{cc} a_{11} & a_{12} \\ a_{21} & a_{22}  \end{array} \right) = a_{11} a_{22} - a_{12} a_{21}

Вычисление определителя матрицы по определению требует порядка
:math:`n!` операций, поэтому разработаны методы, которые позволяют
вычислять его быстро и эффективно.

В ``NumPy`` определитель матрицы вычисляется с помощью функции
**numpy.linalg.det(a)**, где **a** — исходная матрица.

.. code:: python

    a = np.array([[1, 2, 1], [1, 1, 4], [2, 3, 6]], dtype=np.float32)
    det = np.linalg.det(a)

.. code:: python

    print ("Матрица:\n", a)
    print ("Определитель:\n", det)


.. parsed-literal::

    Матрица:
     [[1. 2. 1.]
     [1. 1. 4.]
     [2. 3. 6.]]
    Определитель:
     -1.0


Рассмотрим одно интересное свойство определителя. Пусть у нас есть
параллелограмм с углами в точках
:math:`(0, 0), (c,d), (a+c, b+d), (a, b)` (углы даны в порядке обхода по
часовой стрелке). Тогда площадь этого параллелограмма можно вычислить
как модуль определителя матрицы
:math:`\left( \begin{array}{cc} a & c \\ b & d \end{array} \right)`.
Похожим образом можно выразить и объем параллелепипеда через
определитель матрицы размера :math:`3 \times 3`.

10. Ранг матрицы
----------------

**Напоминание теории.** **Рангом матрицы** :math:`A` называется
максимальное число линейно независимых строк (столбцов) этой матрицы.

В ``NumPy`` ранг матрицы вычисляется с помощью функции
**numpy.linalg.matrix_rank(M, tol=None)**, где **M** — матрица,
**tol** — параметр, отвечающий за некоторую точность вычисления. В
простом случае можно его не задавать, и функция сама определит
подходящее значение этого параметра.

.. code:: python

    a = np.array([[1, 2, 3], [1, 1, 1], [2, 2, 2]])
    r = np.linalg.matrix_rank(a)

.. code:: python

    print ("Матрица:\n", a)
    print ("Ранг матрицы:", r)


.. parsed-literal::

    Матрица:
     [[1 2 3]
     [1 1 1]
     [2 2 2]]
    Ранг матрицы: 2


С помощью вычисления ранга матрицы можно проверять линейную
независимость системы векторов.

Допустим, у нас есть несколько векторов. Составим из них матрицу, где
наши векторы будут являться строками. Понятно, что векторы линейно
независимы тогда и только тогда, когда ранг полученной матрицы совпадает
с числом векторов. Приведем пример:

.. code:: python

    a = np.array([1, 2, 3])
    b = np.array([1, 1, 1])
    c = np.array([2, 3, 5])
    m = np.array([a, b, c])

.. code:: python

    print (np.linalg.matrix_rank(m) == m.shape[0])


.. parsed-literal::

    True


11. Системы линейных уравнений
------------------------------

**Напоминание теории.** **Системой линейных алгебраических уравнений**
называется система вида :math:`Ax = b`, где
:math:`A \in \mathbb{R}^{n \times m}, x \in \mathbb{R}^{m \times 1}, b \in \mathbb{R}^{n \times 1}`.
В случае квадратной невырожденной матрицы :math:`A` решение системы
единственно.

В ``NumPy`` решение такой системы можно найти с помощью функции
**numpy.linalg.solve(a, b)**, где первый аргумент — матрица
:math:`A`, второй — столбец :math:`b`.

.. code:: python

    a = np.array([[3, 1], [1, 2]])
    b = np.array([9, 8])
    x = np.linalg.solve(a, b)

.. code:: python

    print ("Матрица A:\n", a)
    print ("Вектор b:\n", b)
    print ("Решение системы:\n", x)


.. parsed-literal::

    Матрица A:
     [[3 1]
     [1 2]]
    Вектор b:
     [9 8]
    Решение системы:
     [2. 3.]


Убедимся, что вектор **x** действительно является решением системы:

.. code:: python

    print (a.dot(x))


.. parsed-literal::

    [9. 8.]


Бывают случаи, когда решение системы не существует. Но хотелось бы все
равно “решить” такую систему. Логичным кажется искать такой вектор
:math:`x`, который минимизирует выражение
:math:`\left\Vert Ax - b\right\Vert^{2}` — так мы приблизим выражение
:math:`Ax` к :math:`b`.

В ``NumPy`` такое псевдорешение можно искать с помощью функции
**numpy.linalg.lstsq(a, b, ...)**, где первые два аргумента такие
же, как и для функции **numpy.linalg.solve()**. Помимо решения
функция возвращает еще три значения, которые нам сейчас не понадобятся.

.. code:: python

    a = np.array([[0, 1], [1, 1], [2, 1], [3, 1]])
    b = np.array([-1, 0.2, 0.9, 2.1])
    x, res, r, s = np.linalg.lstsq(a, b, rcond=None)

.. code:: python

    print ("Матрица A:\n", a)
    print ("Вектор b:\n", b)
    print ("Псевдорешение системы:\n", x)


.. parsed-literal::

    Матрица A:
     [[0 1]
     [1 1]
     [2 1]
     [3 1]]
    Вектор b:
     [-1.   0.2  0.9  2.1]
    Псевдорешение системы:
     [ 1.   -0.95]


12. Обращение матриц
--------------------

**Напоминание теории.** Для квадратных невырожденных матриц определено
понятие **обратной** матрицы.

Пусть :math:`A` — квадратная невырожденная матрица. Матрица
:math:`A^{-1}` называется **обратной матрицей** к :math:`A`, если

.. math::

   AA^{-1} = A^{-1}A = I,

где :math:`I` — единичная матрица.

В ``NumPy`` обратные матрицы вычисляются с помощью функции
**numpy.linalg.inv(a)**, где **a** — исходная матрица.

.. code:: python

    a = np.array([[1, 2, 1], [1, 1, 4], [2, 3, 6]], dtype=np.float32)
    b = np.linalg.inv(a)

.. code:: python

    print ("Матрица A:\n", a)
    print ("Обратная матрица к A:\n", b)
    print ("Произведение A на обратную должна быть единичной:\n", a.dot(b))


.. parsed-literal::

    Матрица A:
     [[1. 2. 1.]
     [1. 1. 4.]
     [2. 3. 6.]]
    Обратная матрица к A:
     [[ 6.  9. -7.]
     [-2. -4.  3.]
     [-1. -1.  1.]]
    Произведение A на обратную должна быть единичной:
     [[1. 0. 0.]
     [0. 1. 0.]
     [0. 0. 1.]]


13. Собственные числа и собственные вектора матрицы
---------------------------------------------------

**Напоминание теории.** Для квадратных матриц определены понятия
**собственного вектора** и **собственного числа**.

Пусть :math:`A` — квадратная матрица и
:math:`A \in \mathbb{R}^{n \times n}`. **Собственным вектором** матрицы
:math:`A` называется такой ненулевой вектор
:math:`x \in \mathbb{R}^{n}`, что для некоторого
:math:`\lambda \in \mathbb{R}` выполняется равенство
:math:`Ax = \lambda x`. При этом :math:`\lambda` называется
**собственным числом** матрицы :math:`A`. Собственные числа и
собственные векторы матрицы играют важную роль в теории линейной алгебры
и ее практических приложениях.

В ``NumPy`` собственные числа и собственные векторы матрицы вычисляются
с помощью функции **numpy.linalg.eig(a)**, где **a** — исходная
матрица. В качестве результата эта функция выдает одномерный массив
**w** собственных чисел и двумерный массив **v**, в котором по
столбцам записаны собственные вектора, так что вектор **v[:, i]**
соотвествует собственному числу **w[i]**.

.. code:: python

    a = np.array([[-1, -6], [2, 6]])
    w, v = np.linalg.eig(a)

.. code:: python

    print ("Матрица A:\n", a)
    print ("Собственные числа:\n", w)
    print ("Собственные векторы:\n", v)


.. parsed-literal::

    Матрица A:
     [[-1 -6]
     [ 2  6]]
    Собственные числа:
     [2. 3.]
    Собственные векторы:
     [[-0.89442719  0.83205029]
     [ 0.4472136  -0.5547002 ]]


**Обратите внимание:** у вещественной матрицы собственные значения или
собственные векторы могут быть комплексными.

14. Расстояния между векторами
------------------------------

Вспомним некоторые нормы, которые можно ввести в пространстве
:math:`\mathbb{R}^{n}`, и рассмотрим, с помощью каких библиотек и
функций их можно вычислять в ``NumPy``.

p-норма
======================

p-норма (норма Гёльдера) для вектора
:math:`x = (x_{1}, \dots, x_{n}) \in \mathbb{R}^{n}` вычисляется по
формуле:

.. math::


   \left\Vert x \right\Vert_{p} = \left( \sum_{i=1}^n \left| x_{i} \right|^{p} \right)^{1 / p},~p \geq 1.

В частных случаях при: \* :math:`p = 1` получаем :math:`\ell_{1}` норму
\* :math:`p = 2` получаем :math:`\ell_{2}` норму

Далее нам понабится модуль ``numpy.linalg``, реализующий некоторые
приложения линейной алгебры. Для вычисления различных норм мы используем
функцию **numpy.linalg.norm(x, ord=None, ...)**, где **x** —
исходный вектор, **ord** — параметр, определяющий норму (мы
рассмотрим два варианта его значений — 1 и 2). Импортируем эту функцию:

.. code:: python

    from numpy.linalg import norm

:math:`\ell_{1}` норма
======================


:math:`\ell_{1}` норма (также известная как `манхэттенское
расстояние <https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%B3%D0%BE%D1%80%D0%BE%D0%B4%D1%81%D0%BA%D0%B8%D1%85_%D0%BA%D0%B2%D0%B0%D1%80%D1%82%D0%B0%D0%BB%D0%BE%D0%B2>`__)
для вектора :math:`x = (x_{1}, \dots, x_{n}) \in \mathbb{R}^{n}`
вычисляется по формуле:

.. math::


    \left\Vert x \right\Vert_{1} = \sum_{i=1}^n \left| x_{i} \right|.

Ей в функции **numpy.linalg.norm(x, ord=None, ...)** соответствует
параметр **ord=1**.

.. code:: python

    a = np.array([1, 2, -3])
    print('Вектор a:', a)


.. parsed-literal::

    Вектор a: [ 1  2 -3]


.. code:: python

    print('L1 норма вектора a:\n', norm(a, ord=1))


.. parsed-literal::

    L1 норма вектора a:
     6.0


:math:`\ell_{2}` норма
======================

:math:`\ell_{2}` норма (также известная как евклидова норма) для вектора
:math:`x = (x_{1}, \dots, x_{n}) \in \mathbb{R}^{n}` вычисляется по
формуле:

.. math::


    \left\Vert x \right\Vert_{2} = \sqrt{\sum_{i=1}^n \left( x_{i} \right)^2}.

Ей в функции **numpy.linalg.norm(x, ord=None, ...)** соответствует
параметр **ord=2**.

.. code:: python

    print ('L2 норма вектора a:\n', norm(a, ord=2))


.. parsed-literal::

    L2 норма вектора a:
     3.7416573867739413


Более подробно о том, какие еще нормы (в том числе матричные) можно
вычислить, см.
`документацию <http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.linalg.norm.html>`__.

15. Расстояния между векторами
------------------------------

Для двух векторов :math:`x = (x_{1}, \dots, x_{n}) \in \mathbb{R}^{n}` и
:math:`y = (y_{1}, \dots, y_{n}) \in \mathbb{R}^{n}` :math:`\ell_{1}` и
:math:`\ell_{2}` раccтояния вычисляются по следующим формулам
соответственно:

.. math::


    \rho_{1}\left( x, y \right) = \left\Vert x - y \right\Vert_{1} = \sum_{i=1}^n \left| x_{i} - y_{i} \right|

.. math::


    \rho_{2}\left( x, y \right) = \left\Vert x - y \right\Vert_{2} =
    \sqrt{\sum_{i=1}^n \left( x_{i} - y_{i} \right)^2}.

.. code:: python

    a = np.array([1, 2, -3])
    b = np.array([-4, 3, 8])
    print ('Вектор a:', a)
    print ('Вектор b:', b)


.. parsed-literal::

    Вектор a: [ 1  2 -3]
    Вектор b: [-4  3  8]


.. code:: python

    print ('L1 расстояние между векторами a и b:\n', norm(a - b, ord=1))
    print ('L2 расстояние между векторами a и b:\n', norm(a - b, ord=2))


.. parsed-literal::

    L1 расстояние между векторами a и b:
     17.0
    L2 расстояние между векторами a и b:
     12.12435565298214


16. Скалярное произведение и угол между векторами
-------------------------------------------------

.. code:: python

    a = np.array([0, 5, -1])
    b = np.array([-4, 9, 3])
    print ('Вектор a:', a)
    print ('Вектор b:', b)


.. parsed-literal::

    Вектор a: [ 0  5 -1]
    Вектор b: [-4  9  3]


Скалярное произведение в пространстве :math:`\mathbb{R}^{n}` для двух
векторов :math:`x = (x_{1}, \dots, x_{n})` и
:math:`y = (y_{1}, \dots, y_{n})` определяется как:

.. math::


   \langle x, y \rangle = \sum_{i=1}^n x_{i} y_{i}.

Длиной вектора :math:`x = (x_{1}, \dots, x_{n}) \in \mathbb{R}^{n}`
называется квадратный корень из скалярного произведения, то есть длина
равна евклидовой норме вектора:

.. math::


   \left| x \right| = \sqrt{\langle x, x \rangle} = \sqrt{\sum_{i=1}^n x_{i}^2} =  \left\Vert x \right\Vert_{2}.

Теперь, когда мы знаем расстояние между двумя ненулевыми векторами и их
длины, мы можем вычислить угол между ними через скалярное произведение:

.. math::


   \langle x, y \rangle = \left| x \right| | y | \cos(\alpha)
   \implies \cos(\alpha) = \frac{\langle x, y \rangle}{\left| x \right| | y |},

где :math:`\alpha \in [0, \pi]` — угол между векторами :math:`x` и
:math:`y`.

.. code:: python

    cos_angle = np.dot(a, b) / norm(a) / norm(b)
    print ('Косинус угла между a и b:', cos_angle)
    print ('Сам угол:', np.arccos(cos_angle))


.. parsed-literal::

    Косинус угла между a и b: 0.8000362836474323
    Сам угол: 0.6434406336093618


17. Комплексные числа в питоне
------------------------------

**Напоминание теории.** **Комплексными числами** называются числа вида
:math:`x + iy`, где :math:`x` и :math:`y` — вещественные числа, а
:math:`i` — мнимая единица (величина, для которой выполняется равенство
:math:`i^{2} = -1`). Множество всех комплексных чисел обозначается
буквой :math:`\mathbb{C}` (подробнее про комплексные числа см.
`википедию <https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE>`__).

В питоне комплескные числа можно задать следующим образом (**j**
обозначает мнимую единицу):

.. code:: python

    a = 3 + 2j
    b = 1j

.. code:: python

    print ("Комплексное число a:\n", a)
    print ("Комплексное число b:\n", b)


.. parsed-literal::

    Комплексное число a:
     (3+2j)
    Комплексное число b:
     1j


С комплексными числами в питоне можно производить базовые арифметические
операции так же, как и с вещественными числами:

.. code:: python

    c = a * a
    d = a / (4 - 5j)

.. code:: python

    print ("Комплексное число c:\n", c)
    print ("Комплексное число d:\n", d)


.. parsed-literal::

    Комплексное число c:
     (5+12j)
    Комплексное число d:
     (0.0487804878048781+0.5609756097560976j)


Задания: (Блок 2)
=================

Задание 3:
~~~~~~~~~~

Рассмотрим сложную математическую функцию на отрезке [1, 15]:

f(x) = sin(x / 5) \* exp(x / 10) + 5 \* exp(-x / 2)

.. figure:: {filename}/images/lab14/func.png
   :alt: images/lab14/func.png


Она может описывать, например, зависимость оценок, которые выставляют
определенному сорту вина эксперты, в зависимости от возраста этого вина.
Мы хотим приблизить сложную зависимость с помощью функции из
определенного семейства. В этом задании мы будем приближать указанную
функцию с помощью многочленов.

Как известно, многочлен степени :math:`n` (то есть :math:`w_0` +
:math:`w_1 x` + :math:`w_2 x^2` + :math:`\ldots` + :math:`w_n x^n`)
однозначно определяется любыми n + 1 различными точками, через которые
он проходит. Это значит, что его коэффициенты :math:`w_0`, … :math:`w_n`
можно определить из следующей системы линейных уравнений:

.. figure:: {filename}/images/lab14/eqs.png
   :alt: images/lab14/eqs.png


где через :math:`x_1, ..., x_n, x_{n+1}` обозначены точки, через которые
проходит многочлен, а через :math:`f(x_1), ..., f(x_n), f(x_{n+1})` —
значения, которые он должен принимать в этих точках.

Воспользуемся описанным свойством, и будем находить приближение функции
многочленом, решая систему линейных уравнений.

1. Сформируйте систему линейных уравнений (то есть задайте матрицу
   коэффициентов A и свободный вектор b) для многочлена первой степени,
   который должен совпадать с функцией f в точках 1 и 15. Решите данную
   систему с помощью функции scipy.linalg.solve. Нарисуйте функцию f и
   полученный многочлен. Хорошо ли он приближает исходную функцию?
2. Повторите те же шаги для многочлена второй степени, который совпадает
   с функцией f в точках 1, 8 и 15. Улучшилось ли качество
   аппроксимации?
3. Повторите те же шаги для многочлена третьей степени, который
   совпадает с функцией f в точках 1, 4, 10 и 15. Хорошо ли он
   аппроксимирует функцию? Коэффициенты данного многочлена (четыре числа
   в следующем порядке: w_0, w_1, w_2, w_3) являются ответом на задачу.
   Округлять коэффициенты не обязательно, но при желании можете
   произвести округление до второго знака (т.е. до числа вида 0.42)
